19:13:54 **** Rebuild of configuration Debug for project code2 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodavettore.o" "..\\src\\testcodavettore.cpp" 
g++ -o code2.exe "src\\testcodavettore.o" 
Info: Nothing to build for code2
16:58:42 **** Rebuild of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
In file included from ..\src\hashAperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:6:26: fatal error: listaLineare.h: No such file or directory
 #include "listaLineare.h"
                          ^
compilation terminated.
16:58:45 **** Rebuild of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
16:59:11 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
In file included from ..\src\hashAperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:6:26: fatal error: listalineare.h: No such file or directory
 #include "listalineare.h"
                          ^
compilation terminated.
16:59:11 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:08 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashchiuso.o: In function `ZNK9hashClassIiEclEi':
C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashchiuso.cpp:8: multiple definition of `main'
src\testhashaperto.o:C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashaperto.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:08 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:36 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashchiuso.o: In function `ZNK9hashClassIiEclEi':
C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashchiuso.cpp:8: multiple definition of `main'
src\testhashaperto.o:C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashaperto.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:37 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:44 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashchiuso.o: In function `ZNK9hashClassIiEclEi':
C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashchiuso.cpp:8: multiple definition of `main'
src\testhashaperto.o:C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashaperto.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:00:45 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:03:08 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
..\src\testhashaperto.cpp:26:2: error: 'cout' does not name a type
  cout << d << endl;
  ^~~~
..\src\testhashaperto.cpp:28:2: error: expected unqualified-id before 'return'
  return (0);
  ^~~~~~
..\src\testhashaperto.cpp:29:1: error: expected declaration before '}' token
 }
 ^
17:03:08 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistavettore.o: In function `ZN13listExceptionD2Ev':
C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistavettore.cpp:8: multiple definition of `main'
src\testlistapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\liste\Debug/../src/testlistapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
17:03:15 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
..\src\testhashaperto.cpp:26:2: error: 'cout' does not name a type
  cout << d << endl;
  ^~~~
..\src\testhashaperto.cpp:28:2: error: expected unqualified-id before 'return'
  return (0);
  ^~~~~~
..\src\testhashaperto.cpp:29:1: error: expected declaration before '}' token
 }
 ^
17:03:34 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
..\src\testhashaperto.cpp:26:2: error: 'cout' does not name a type
  cout << d << endl;
  ^~~~
..\src\testhashaperto.cpp:28:2: error: expected unqualified-id before 'return'
  return (0);
  ^~~~~~
17:03:36 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
..\src\testhashaperto.cpp:26:2: error: 'cout' does not name a type
  cout << d << endl;
  ^~~~
..\src\testhashaperto.cpp:28:2: error: expected unqualified-id before 'return'
  return (0);
  ^~~~~~
17:03:40 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
..\src\testhashaperto.cpp:26:2: error: 'cout' does not name a type
  cout << d << endl;
  ^~~~
17:03:46 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
..\src\testhashaperto.cpp:11:2: error: 'd' does not name a type
  d.inserisci(1, 10);
  ^
..\src\testhashaperto.cpp:12:2: error: 'd' does not name a type
  d.inserisci(3, 30);
  ^
..\src\testhashaperto.cpp:13:2: error: 'd' does not name a type
  d.inserisci(1, 11);
  ^
..\src\testhashaperto.cpp:14:2: error: 'd' does not name a type
  d.inserisci(2, 20);
  ^
..\src\testhashaperto.cpp:15:2: error: 'd' does not name a type
  d.inserisci(10, 100);
  ^
..\src\testhashaperto.cpp:16:2: error: 'd' does not name a type
  d.inserisci(4, 40);
  ^
..\src\testhashaperto.cpp:18:2: error: 'd' does not name a type
  d.inserisci(0, 456);
  ^
..\src\testhashaperto.cpp:20:2: error: 'd' does not name a type
  d.inserisci(400, 40000);
  ^
..\src\testhashaperto.cpp:22:2: error: 'd' does not name a type
  d.cancella(1);
  ^
..\src\testhashaperto.cpp:24:2: error: 'd' does not name a type
  d.aggiornaValore(4, 50);
  ^
17:03:56 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for dizionari
Info: Nothing to build for dizionari
17:08:42 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
..\src\testhashchiuso.cpp:1:1: error: unterminated comment
 /*#include <iostream>
 ^
17:08:53 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for dizionari
17:14:28 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for dizionari
12:19:11 **** Rebuild of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
src\testpilavettore.o: In function `main':
C:\Users\Marco Ferrara\eclipse-workspace\pile\Debug/../src/testpilavettore.cpp:8: multiple definition of `main'
src\testpilapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\pile\Debug/../src/testpilapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
12:19:32 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:20:21 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:21:27 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
12:21:34 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:22:19 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:23:32 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
Info: Nothing to build for pile
Info: Nothing to build for pile
12:31:28 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:32:41 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:36:54 **** Incremental Build of configuration Debug for project pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -o pile.exe "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
Info: Nothing to build for pile
12:42:06 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
12:48:24 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
12:50:28 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
12:52:15 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
12:53:02 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
12:53:38 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for pile
Info: Nothing to build for liste
12:54:10 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
12:56:39 **** Rebuild of configuration Debug for project temp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o temp.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for temp
12:59:20 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
Info: Nothing to build for liste
13:05:10 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:06:06 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:09:24 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for pile
Info: Nothing to build for liste
13:12:46 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for pile
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
13:15:34 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/ld.exe: cannot open output file liste.exe: Permission denied
collect2.exe: error: ld returned 1 exit status
13:15:39 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:20:11 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:20:37 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
Info: Nothing to build for liste
13:21:07 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/ld.exe: cannot open output file liste.exe: Permission denied
collect2.exe: error: ld returned 1 exit status
13:21:11 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:21:20 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:22:50 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:23:08 **** Incremental Build of configuration Debug for project liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o liste.exe "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for liste
13:23:41 **** Rebuild of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:32:15 **** Rebuild of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashchiuso.o: In function `ZNK9hashClassIiEclEi':
C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashchiuso.cpp:8: multiple definition of `main'
src\testhashaperto.o:C:\Users\Marco Ferrara\eclipse-workspace\dizionari\Debug/../src/testhashaperto.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for liste
13:32:28 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for liste
Info: Nothing to build for dizionari
Info: Nothing to build for liste
Info: Nothing to build for dizionari
Info: Nothing to build for dizionari
13:32:59 **** Incremental Build of configuration Debug for project dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -o dizionari.exe "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for dizionari
13:37:52 **** Rebuild of configuration Debug for project code ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodapuntatore.o" "..\\src\\testcodapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodavettore.o" "..\\src\\testcodavettore.cpp" 
g++ -o code.exe "src\\testcodapuntatore.o" "src\\testcodavettore.o" 
src\testcodavettore.o: In function `main':
C:\Users\Marco Ferrara\eclipse-workspace\code\Debug/../src/testcodavettore.cpp:8: multiple definition of `main'
src\testcodapuntatore.o:C:\Users\Marco Ferrara\eclipse-workspace\code\Debug/../src/testcodapuntatore.cpp:8: first defined here
collect2.exe: error: ld returned 1 exit status
13:38:07 **** Incremental Build of configuration Debug for project code ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodapuntatore.o" "..\\src\\testcodapuntatore.cpp" 
g++ -o code.exe "src\\testcodapuntatore.o" "src\\testcodavettore.o" 
Info: Nothing to build for code
13:42:47 **** Incremental Build of configuration Debug for project code ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodavettore.o" "..\\src\\testcodavettore.cpp" 
g++ -o code.exe "src\\testcodapuntatore.o" "src\\testcodavettore.o" 
13:42:48 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
Info: Nothing to build for insiemi
Info: Nothing to build for insiemi
Info: Nothing to build for insiemi
13:43:25 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:43:52 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:45:17 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:45:28 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:46:25 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:47:21 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:48:33 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:49:08 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:49:17 **** Incremental Build of configuration Debug for project insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o insiemi.exe "src\\testinsiemi.o" 
Info: Nothing to build for insiemi
13:58:12 **** Incremental Build of configuration Debug for project code ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodapuntatore.o" "..\\src\\testcodapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodavettore.o" "..\\src\\testcodavettore.cpp" 
g++ -o code.exe "src\\testcodapuntatore.o" "src\\testcodavettore.o" 
Info: Nothing to build for code
14:25:59 **** Rebuild of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In function 'std::ostream& operator<<(std::ostream&, const alberoBinArray<T>&)':
..\src\alberoBinArray.h:56:30: error: 'NIL' was not declared in this scope
      if (a.array[i].padre != NIL)
                              ^~~
..\src\alberoBinArray.h:60:33: error: 'NIL' was not declared in this scope
      if (a.array[i].sinistro != NIL)
                                 ^~~
..\src\alberoBinArray.h:64:31: error: 'NIL' was not declared in this scope
      if (a.array[i].destro != NIL)
                               ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioSinistro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:149:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioDestro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:158:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::sinistroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:165:38: error: 'NIL' was not declared in this scope
   return (this->array[p].sinistro == NIL);
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::destroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:174:36: error: 'NIL' was not declared in this scope
   return (this->array[p].destro == NIL);
                                    ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::costrBinAlbero(alberoBinArray<T>, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:183:36: error: 'NIL' was not declared in this scope
  this->array[this->libero].padre = NIL; // setta il valore del padre della nuova radice a NIL poichè è una radice
                                    ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::cancSottoBinAlbero(alberoBinArray<T>::posizione)':
..\src\alberoBinArray.h:236:44: error: 'NIL' was not declared in this scope
                 array[genitore].sinistro = NIL;
                                            ^~~
..\src\alberoBinArray.h:238:42: error: 'NIL' was not declared in this scope
                 array[genitore].destro = NIL;
                                          ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insBinRadice(alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:271:21: error: 'NIL' was not declared in this scope
  if(this->radice == NIL){
                     ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioSinistro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:294:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioDestro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:313:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:369:38: error: 'NIL' was not declared in this scope
   if (trovaValore(binRadice(), e) != NIL)
                                      ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::ricercaElemento(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:385:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::trovaValore(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:400:14: error: 'NIL' was not declared in this scope
    if(pos != NIL)
              ^~~
..\src\alberoBinArray.h:405:15: error: 'NIL' was not declared in this scope
    if (pos != NIL)
               ^~~
..\src\alberoBinArray.h:409:9: error: 'NIL' was not declared in this scope
  return NIL;
         ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::creaBinAlbero() [with T = int]':
..\src\alberoBinArray.h:97:2:   required from 'alberoBinArray<T>::alberoBinArray() [with T = int]'
..\src\testalberobinarray.cpp:50:22:   required from here
..\src\alberoBinArray.h:123:15: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
  this->radice = nullptr;
  ~~~~~~~~~~~~~^~~~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::cancSottoBinAlbero(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:72:1:   required from here
..\src\alberoBinArray.h:241:20: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
             radice = nullptr;
             ~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int]':
..\src\alberoBinArray.h:377:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
14:26:09 **** Incremental Build of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In function 'std::ostream& operator<<(std::ostream&, const alberoBinArray<T>&)':
..\src\alberoBinArray.h:56:30: error: 'NIL' was not declared in this scope
      if (a.array[i].padre != NIL)
                              ^~~
..\src\alberoBinArray.h:60:33: error: 'NIL' was not declared in this scope
      if (a.array[i].sinistro != NIL)
                                 ^~~
..\src\alberoBinArray.h:64:31: error: 'NIL' was not declared in this scope
      if (a.array[i].destro != NIL)
                               ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioSinistro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:149:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioDestro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:158:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::sinistroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:165:38: error: 'NIL' was not declared in this scope
   return (this->array[p].sinistro == NIL);
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::destroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:174:36: error: 'NIL' was not declared in this scope
   return (this->array[p].destro == NIL);
                                    ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::costrBinAlbero(alberoBinArray<T>, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:183:36: error: 'NIL' was not declared in this scope
  this->array[this->libero].padre = NIL; // setta il valore del padre della nuova radice a NIL poichè è una radice
                                    ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insBinRadice(alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:271:21: error: 'NIL' was not declared in this scope
  if(this->radice == NIL){
                     ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioSinistro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:294:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioDestro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:313:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:369:38: error: 'NIL' was not declared in this scope
   if (trovaValore(binRadice(), e) != NIL)
                                      ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::ricercaElemento(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:385:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::trovaValore(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:400:14: error: 'NIL' was not declared in this scope
    if(pos != NIL)
              ^~~
..\src\alberoBinArray.h:405:15: error: 'NIL' was not declared in this scope
    if (pos != NIL)
               ^~~
..\src\alberoBinArray.h:409:9: error: 'NIL' was not declared in this scope
  return NIL;
         ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::creaBinAlbero() [with T = int]':
..\src\alberoBinArray.h:97:2:   required from 'alberoBinArray<T>::alberoBinArray() [with T = int]'
..\src\testalberobinarray.cpp:50:22:   required from here
..\src\alberoBinArray.h:123:15: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
  this->radice = nullptr;
  ~~~~~~~~~~~~~^~~~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::cancSottoBinAlbero(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:72:1:   required from here
..\src\alberoBinArray.h:236:42: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].sinistro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:238:40: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].destro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:241:20: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
             radice = nullptr;
             ~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int]':
..\src\alberoBinArray.h:377:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
14:26:15 **** Incremental Build of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In function 'std::ostream& operator<<(std::ostream&, const alberoBinArray<T>&)':
..\src\alberoBinArray.h:56:30: error: 'NIL' was not declared in this scope
      if (a.array[i].padre != NIL)
                              ^~~
..\src\alberoBinArray.h:60:33: error: 'NIL' was not declared in this scope
      if (a.array[i].sinistro != NIL)
                                 ^~~
..\src\alberoBinArray.h:64:31: error: 'NIL' was not declared in this scope
      if (a.array[i].destro != NIL)
                               ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioSinistro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:149:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioDestro(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:158:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::sinistroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:165:38: error: 'NIL' was not declared in this scope
   return (this->array[p].sinistro == NIL);
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::destroVuoto(alberoBinArray<T>::posizione) const':
..\src\alberoBinArray.h:174:36: error: 'NIL' was not declared in this scope
   return (this->array[p].destro == NIL);
                                    ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::costrBinAlbero(alberoBinArray<T>, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:183:36: error: 'NIL' was not declared in this scope
  this->array[this->libero].padre = NIL; // setta il valore del padre della nuova radice a NIL poichè è una radice
                                    ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insBinRadice(alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:271:21: error: 'NIL' was not declared in this scope
  if(this->radice == NIL){
                     ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioSinistro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:294:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'void alberoBinArray<T>::insFiglioDestro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem)':
..\src\alberoBinArray.h:313:38: error: 'NIL' was not declared in this scope
   this->array[this->libero].destro = NIL;
                                      ^~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:369:38: error: 'NIL' was not declared in this scope
   if (trovaValore(binRadice(), e) != NIL)
                                      ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::ricercaElemento(alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:385:10: error: 'NIL' was not declared in this scope
   return NIL;
          ^~~
..\src\alberoBinArray.h: In member function 'alberoBinArray<T>::posizione alberoBinArray<T>::trovaValore(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) const':
..\src\alberoBinArray.h:400:14: error: 'NIL' was not declared in this scope
    if(pos != NIL)
              ^~~
..\src\alberoBinArray.h:405:15: error: 'NIL' was not declared in this scope
    if (pos != NIL)
               ^~~
..\src\alberoBinArray.h:409:9: error: 'NIL' was not declared in this scope
  return NIL;
         ^~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::creaBinAlbero() [with T = int]':
..\src\alberoBinArray.h:97:2:   required from 'alberoBinArray<T>::alberoBinArray() [with T = int]'
..\src\testalberobinarray.cpp:50:22:   required from here
..\src\alberoBinArray.h:123:15: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
  this->radice = nullptr;
  ~~~~~~~~~~~~~^~~~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::cancSottoBinAlbero(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:72:1:   required from here
..\src\alberoBinArray.h:236:42: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].sinistro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:238:40: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].destro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:241:20: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
             radice = nullptr;
             ~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int]':
..\src\alberoBinArray.h:377:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
14:26:31 **** Incremental Build of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::insBinRadice(alberoBinArray<T>::tipoelem) [with T = int; alberoBinArray<T>::tipoelem = int]':
..\src\testalberobinarray.cpp:52:21:   required from here
..\src\alberoBinArray.h:271:18: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator=='
  if(this->radice == nullptr){
     ~~~~~~~~~~~~~^~~~~~~~~~
..\src\alberoBinArray.h:274:35: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->radice].padre = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:275:36: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->radice].destro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:276:38: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->radice].sinistro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::insFiglioSinistro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]':
..\src\testalberobinarray.cpp:54:29:   required from here
..\src\alberoBinArray.h:294:36: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->libero].destro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:295:38: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->libero].sinistro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::insFiglioDestro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]':
..\src\testalberobinarray.cpp:55:27:   required from here
..\src\alberoBinArray.h:313:36: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->libero].destro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:314:38: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
   this->array[this->libero].sinistro = nullptr;
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const alberoBinArray<int>&)':
..\src\testalberobinarray.cpp:60:10:   required from here
..\src\alberoBinArray.h:56:27: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
      if (a.array[i].padre != nullptr)
          ~~~~~~~~~~~~~~~~~^~~~~~~~~~
..\src\alberoBinArray.h:60:30: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
      if (a.array[i].sinistro != nullptr)
          ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
..\src\alberoBinArray.h:64:28: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
      if (a.array[i].destro != nullptr)
          ~~~~~~~~~~~~~~~~~~^~~~~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int; alberoBinArray<T>::tipoelem = int]':
..\src\testalberobinarray.cpp:64:27:   required from here
..\src\alberoBinArray.h:369:35: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
   if (trovaValore(binRadice(), e) != nullptr)
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'alberoBinArray<T>::posizione alberoBinArray<T>::ricercaElemento(alberoBinArray<T>::tipoelem) const [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]':
..\src\testalberobinarray.cpp:69:65:   required from here
..\src\alberoBinArray.h:385:10: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in return
   return nullptr;
          ^~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::creaBinAlbero() [with T = int]':
..\src\alberoBinArray.h:97:2:   required from 'alberoBinArray<T>::alberoBinArray() [with T = int]'
..\src\testalberobinarray.cpp:50:22:   required from here
..\src\alberoBinArray.h:123:15: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
  this->radice = nullptr;
  ~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'bool alberoBinArray<T>::sinistroVuoto(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]':
..\src\alberoBinArray.h:290:76:   required from 'void alberoBinArray<T>::insFiglioSinistro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]'
..\src\testalberobinarray.cpp:54:29:   required from here
..\src\alberoBinArray.h:165:35: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator=='
   return (this->array[p].sinistro == nullptr);
          ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'bool alberoBinArray<T>::destroVuoto(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]':
..\src\alberoBinArray.h:309:76:   required from 'void alberoBinArray<T>::insFiglioDestro(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]'
..\src\testalberobinarray.cpp:55:27:   required from here
..\src\alberoBinArray.h:174:33: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator=='
   return (this->array[p].destro == nullptr);
          ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~
..\src\alberoBinArray.h: In instantiation of 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioSinistro(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]':
..\src\alberoBinArray.h:349:48:   required from 'alberoBinArray<T>::posizione alberoBinArray<T>::getFratello(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]'
..\src\testalberobinarray.cpp:62:69:   required from here
..\src\alberoBinArray.h:149:10: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in return
   return nullptr;
          ^~~~~~~
..\src\alberoBinArray.h: In instantiation of 'alberoBinArray<T>::posizione alberoBinArray<T>::figlioDestro(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]':
..\src\alberoBinArray.h:350:50:   required from 'alberoBinArray<T>::posizione alberoBinArray<T>::getFratello(alberoBinArray<T>::posizione) const [with T = int; alberoBinArray<T>::posizione = int]'
..\src\testalberobinarray.cpp:62:69:   required from here
..\src\alberoBinArray.h:158:10: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in return
   return nullptr;
          ^~~~~~~
In file included from ..\src\testalberobinarray.cpp:4:0:
..\src\alberoBinArray.h: In instantiation of 'alberoBinArray<T>::posizione alberoBinArray<T>::trovaValore(alberoBinArray<T>::posizione, alberoBinArray<T>::tipoelem) const [with T = int; alberoBinArray<T>::posizione = int; alberoBinArray<T>::tipoelem = int]':
..\src\alberoBinArray.h:369:18:   required from 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int; alberoBinArray<T>::tipoelem = int]'
..\src\testalberobinarray.cpp:64:27:   required from here
..\src\alberoBinArray.h:400:11: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
    if(pos != nullptr)
       ~~~~^~~~~~~~~~
..\src\alberoBinArray.h:405:12: error: invalid operands of types 'alberoBinArray<int>::posizione {aka int}' and 'std::nullptr_t' to binary 'operator!='
    if (pos != nullptr)
        ~~~~^~~~~~~~~~
..\src\alberoBinArray.h:409:9: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in return
  return nullptr;
         ^~~~~~~
..\src\alberoBinArray.h: In instantiation of 'void alberoBinArray<T>::cancSottoBinAlbero(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:72:1:   required from here
..\src\alberoBinArray.h:236:42: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].sinistro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:238:40: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
                 array[genitore].destro = nullptr;
                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h:241:20: error: cannot convert 'std::nullptr_t' to 'alberoBinArray<int>::posizione {aka int}' in assignment
             radice = nullptr;
             ~~~~~~~^~~~~~~~~
..\src\alberoBinArray.h: In member function 'bool alberoBinArray<T>::valorePresente(alberoBinArray<T>::tipoelem) const [with T = int]':
..\src\alberoBinArray.h:377:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
14:27:21 **** Incremental Build of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o alb_bin.exe "src\\testalberobinarray.o" 
Info: Nothing to build for alb_bin
Info: Nothing to build for alb_bin
14:28:28 **** Incremental Build of configuration Debug for project alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o alb_bin.exe "src\\testalberobinarray.o" 
Info: Nothing to build for alb_bin
18:50:47 **** Rebuild of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistavettore.o" "..\\src\\testlistavettore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o "1 liste.exe" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
18:50:48 **** Rebuild of configuration Debug for project 2 pile ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilavettore.o" "..\\src\\testpilavettore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testpilapuntatore.o" "..\\src\\testpilapuntatore.cpp" 
g++ -o "2 pile.exe" "src\\testpilapuntatore.o" "src\\testpilavettore.o" 
18:50:49 **** Rebuild of configuration Debug for project 3 code ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodapuntatore.o" "..\\src\\testcodapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testcodavettore.o" "..\\src\\testcodavettore.cpp" 
g++ -o "3 code.exe" "src\\testcodapuntatore.o" "src\\testcodavettore.o" 
18:50:50 **** Rebuild of configuration Debug for project 4 insiemi ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testinsiemi.o" "..\\src\\testinsiemi.cpp" 
g++ -o "4 insiemi.exe" "src\\testinsiemi.o" 
18:50:50 **** Rebuild of configuration Debug for project 5 alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o "5 alb_bin.exe" "src\\testalberobinarray.o" 
18:50:51 **** Rebuild of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
18:50:52 **** Rebuild of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
18:50:53 **** Rebuild of configuration Debug for project 8 code_prior ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testprioricode.o" "..\\src\\testprioricode.cpp" 
In file included from ..\src\testprioricode.cpp:3:0:
..\src\prioriCode.h: In instantiation of 'prioriCoda<T>::tipoelem prioriCoda<T>::min() const [with T = int; prioriCoda<T>::tipoelem = int]':
..\src\prioriCode.h:92:30:   required from 'void prioriCoda<T>::cancellaMin() [with T = int]'
..\src\testprioricode.cpp:35:16:   required from here
..\src\prioriCode.h:82:51: error: passing 'const alberoBinArray<int>' as 'this' argument discards qualifiers [-fpermissive]
         return albero.leggiNodo(albero.binRadice());
                                                   ^
In file included from ..\src\prioriCode.h:4:0,
                 from ..\src\testprioricode.cpp:3:
..\src\alberoBinArray.h:253:38: note:   in call to 'alberoBinArray<T>::tipoelem alberoBinArray<T>::leggiNodo(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::tipoelem = int; alberoBinArray<T>::posizione = int]'
 typename alberoBinArray<T>::tipoelem alberoBinArray<T>::leggiNodo(typename alberoBinArray<T>::posizione p){
                                      ^~~~~~~~~~~~~~~~~
18:50:53 **** Rebuild of configuration Debug for project Lab1 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\array.o" "..\\src\\array.cpp" 
g++ -o Lab1.exe "src\\array.o" 
Info: Nothing to build for Lab1
Info: Nothing to build for Lab1
18:55:58 **** Rebuild of configuration Debug for project Lab2 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\provastudente.o" "..\\src\\provastudente.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\studente.o" "..\\src\\studente.cpp" 
g++ -o Lab2.exe "src\\provastudente.o" "src\\studente.o" 
Info: Nothing to build for Lab2
18:57:47 **** Incremental Build of configuration Debug for project Lab1 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
..\src\test.cpp: In function 'int main()':
..\src\test.cpp:44:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
  for (int i = 0; i < B.size(); i++)
                  ~~^~~~~~~~~~
..\src\test.cpp:50:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
  for (int i = 0; i < B.size(); i++)
                  ~~^~~~~~~~~~
In file included from ..\src\test.cpp:1:0:
..\src\array.h: In instantiation of 'void reverse2(std::vector<T>&) [with T = double]':
..\src\test.cpp:48:12:   required from here
..\src\array.h:86:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
  for (int i = 0; i < v.size() - 1; i++){
                  ~~^~~~~~~~~~~~~~
g++ -o Lab1.exe "src\\test.o" 
18:57:48 **** Rebuild of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\Lab3.o" "..\\src\\Lab3.cpp" 
g++ -o Lab3.exe "src\\Lab3.o" 
18:58:20 **** Incremental Build of configuration Debug for project Lab1 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
..\src\test.cpp: In function 'int main()':
..\src\test.cpp:44:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
  for (int i = 0; i < B.size(); i++)
                  ~~^~~~~~~~~~
..\src\test.cpp:50:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
  for (int i = 0; i < B.size(); i++)
                  ~~^~~~~~~~~~
g++ -o Lab1.exe "src\\test.o" 
Info: Nothing to build for Lab3
18:58:33 **** Incremental Build of configuration Debug for project Lab1 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
g++ -o Lab1.exe "src\\test.o" 
Info: Nothing to build for Lab3
19:01:05 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
..\src\matrice.cpp:3:1: error: 'use' does not name a type
 use namespace std;
 ^~~
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:6:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
..\src\matrice.cpp: In member function 'void Matrice::scriviMatrice(int, int, tipoelem)':
..\src\matrice.cpp:39:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
         ^~~
..\src\matrice.cpp:39:96: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
                                                                                                ^~~
..\src\matrice.cpp: In member function 'Matrice Matrice::prodotto(const Matrice&) const':
..\src\matrice.cpp:62:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
         ^~~
..\src\matrice.cpp:62:101: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
                                                                                                     ^~~
19:01:40 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:6:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
..\src\matrice.cpp: In member function 'void Matrice::scriviMatrice(int, int, tipoelem)':
..\src\matrice.cpp:39:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
         ^~~
..\src\matrice.cpp:39:96: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
                                                                                                ^~~
..\src\matrice.cpp: In member function 'Matrice Matrice::prodotto(const Matrice&) const':
..\src\matrice.cpp:62:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
         ^~~
..\src\matrice.cpp:62:101: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
                                                                                                     ^~~
19:02:06 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
..\src\matrice.cpp:2:17: fatal error: stdio: No such file or directory
 #include <stdio>
                 ^
compilation terminated.
19:02:10 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:7:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
..\src\matrice.cpp: In member function 'void Matrice::scriviMatrice(int, int, tipoelem)':
..\src\matrice.cpp:40:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
         ^~~
..\src\matrice.cpp:40:96: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
                                                                                                ^~~
..\src\matrice.cpp: In member function 'Matrice Matrice::prodotto(const Matrice&) const':
..\src\matrice.cpp:63:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
         ^~~
..\src\matrice.cpp:63:101: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
                                                                                                     ^~~
19:02:19 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:5:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
..\src\matrice.cpp: In member function 'void Matrice::scriviMatrice(int, int, tipoelem)':
..\src\matrice.cpp:38:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
         ^~~
..\src\matrice.cpp:38:96: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Tentativo di scrittura al di fuori dei limiti della matrice." << std::endl;
                                                                                                ^~~
..\src\matrice.cpp: In member function 'Matrice Matrice::prodotto(const Matrice&) const':
..\src\matrice.cpp:61:9: error: 'cerr' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
         ^~~
..\src\matrice.cpp:61:101: error: 'endl' is not a member of 'std'
         std::cerr << "Errore: Le dimensioni delle matrici non sono compatibili per il prodotto." << std::endl;
                                                                                                     ^~~
19:02:53 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:5:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
g++ -o Lab3.exe "src\\matrice.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
19:04:50 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -o Lab3.exe "src\\matrice.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
19:04:56 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -o Lab3.exe "src\\matrice.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
19:05:21 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
Info: Nothing to build for Lab3
19:07:04 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:10:02 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
..\src\testmatrice.cpp: In function 'int main()':
..\src\testmatrice.cpp:32:58: error: expected ';' at end of input
     std::cout << "\nMatrice B (trasposta di A):" << std::endl
                                                          ^~~~
..\src\testmatrice.cpp:32:58: error: expected '}' at end of input
19:10:22 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h: In constructor 'Matrice::Matrice(int, int)':
..\src\matrice.h:18:9: warning: 'Matrice::colonne' will be initialized after [-Wreorder]
     int colonne;
         ^~~~~~~
..\src\matrice.h:17:9: warning:   'int Matrice::righe' [-Wreorder]
     int righe;
         ^~~~~
..\src\matrice.cpp:5:1: warning:   when initialized here [-Wreorder]
 Matrice::Matrice(int c, int r) : colonne(c), righe(r) {
 ^~~~~~~
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:11:03 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:11:29 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:12:43 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
..\src\testmatrice.cpp: In function 'int main()':
..\src\testmatrice.cpp:12:7: error: 'class Matrice' has no member named 'scriviMatricMatrice'; did you mean 'scriviMatrice'?
     A.scriviMatricMatrice Matrice::prodotto(const Matrice& M) const {
       ^~~~~~~~~~~~~~~~~~~
..\src\testmatrice.cpp:30:12: error: 'e' was not declared in this scope
 e(1, 2, 6.0);
            ^
19:12:54 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:13:41 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:15:36 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:16:21 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab3
19:18:37 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
..\src\testmatrice.cpp: In function 'int main()':
..\src\testmatrice.cpp:6:5: error: 'Matrice' was not declared in this scope
     Matrice A(2, 3);
     ^~~~~~~
..\src\testmatrice.cpp:7:5: error: 'A' was not declared in this scope
     A.scriviMatrice(0, 0, 1.0);
     ^
..\src\testmatrice.cpp:31:13: error: expected ';' before 'B'
     Matrice B = A.trasposta();
             ^
..\src\testmatrice.cpp:33:25: error: 'B' was not declared in this scope
     for (int i = 0; i < B.getRighe(); ++i) {
                         ^
..\src\testmatrice.cpp:40:13: error: expected ';' before 'C'
     Matrice C = A.prodotto(B);
             ^
..\src\testmatrice.cpp:42:25: error: 'C' was not declared in this scope
     for (int i = 0; i < C.getRighe(); ++i) {
                         ^
19:18:38 **** Rebuild of configuration Debug for project Lab4 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\Lab4.o" "..\\src\\Lab4.cpp" 
g++ -o Lab4.exe "src\\Lab4.o" 
19:19:38 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
..\src\matrice.cpp: In member function 'void matrice::rand()':
..\src\matrice.cpp:97:28: error: 'random' was not declared in this scope
    elementi[i][j] = random() % 100;
                            ^
Info: Nothing to build for Lab4
19:21:03 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab4
Info: Nothing to build for Lab3
19:24:04 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
..\src\matrice.cpp: In member function 'matrice matrice::prodottoMatrici(const matrice&) const':
..\src\matrice.cpp:114:114: error: passing 'const matrice' as 'this' argument discards qualifiers [-fpermissive]
                 risultato.scrivimatrice(i, j, risultato.leggimatrice(i, j) + elementi[i][k] * m.leggimatrice(k, j));
                                                                                                                  ^
..\src\matrice.cpp:62:10: note:   in call to 'tipoelem matrice::leggimatrice(int, int)'
 tipoelem matrice::leggimatrice(int r, int c){
          ^~~~~~~
Info: Nothing to build for Lab4
19:25:10 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
..\src\matrice.cpp:62:10: error: prototype for 'tipoelem matrice::leggimatrice(int, int) const' does not match any in class 'matrice'
 tipoelem matrice::leggimatrice(int r, int c) const {
          ^~~~~~~
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h:12:11: error: candidate is: tipoelem matrice::leggimatrice(int, int)
  tipoelem leggimatrice(int, int);
           ^~~~~~~~~~~~
..\src\matrice.cpp: In member function 'matrice matrice::prodottoMatrici(const matrice&) const':
..\src\matrice.cpp:114:114: error: passing 'const matrice' as 'this' argument discards qualifiers [-fpermissive]
                 risultato.scrivimatrice(i, j, risultato.leggimatrice(i, j) + elementi[i][k] * m.leggimatrice(k, j));
                                                                                                                  ^
In file included from ..\src\matrice.cpp:1:0:
..\src\matrice.h:12:11: note:   in call to 'tipoelem matrice::leggimatrice(int, int)'
  tipoelem leggimatrice(int, int);
           ^~~~~~~~~~~~
Info: Nothing to build for Lab4
19:25:20 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\matrice.o" "..\\src\\matrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab4
19:25:56 **** Incremental Build of configuration Debug for project Lab3 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
g++ -o Lab3.exe "src\\matrice.o" "src\\testmatrice.o" 
Info: Nothing to build for Lab4
Info: Nothing to build for Lab3
19:31:00 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:1:0: error: unterminated #ifndef
 #ifndef _LISTAPUNTATORE_H
 
..\src\listapuntatore.cpp:190:2: error: #endif without #if
 #endif // _LISTAPUNTATORE_H
  ^~~~~
Info: Nothing to build for Lab4
Info: Nothing to build for Lab5
19:31:26 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o "1 liste.exe" "src\\listapuntatore.o" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
src\testlistapuntatore.o: In function `main':
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:9: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:10: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:12: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:12: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:13: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:13: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:15: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:15: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:16: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:16: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:18: undefined reference to `listaPuntatore<int>::operator==(listaPuntatore<int> const&) const'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:10: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:9: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:10: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\Marco Ferrara\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\1 liste\Debug/../src/testlistapuntatore.cpp:9: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for Lab4
Info: Nothing to build for Lab5
19:32:17 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listavettore.o" "..\\src\\listavettore.cpp" 
..\src\listavettore.cpp:1:26: warning: extra tokens at end of #include directive
 #include "listavettore.h";
                          ^
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
In file included from ..\src\testlistapuntatore.cpp:3:0:
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
g++ -o "1 liste.exe" "src\\listapuntatore.o" "src\\listavettore.o" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
Info: Nothing to build for Lab4
Info: Nothing to build for Lab5
Info: Nothing to build for 1 liste
Info: Nothing to build for Lab3
Info: Nothing to build for Lab4
19:02:51 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Configuration "Debug" uses tool-chain "MinGW GCC" that is unsupported on this system, attempting to build anyway.
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
Cannot run program "g++": Launching failed

Error: Program "g++" not found in PATH
PATH=[\bin;\bin;\usr\bin;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin/server;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin;C:/Users/marco/AppData/Local/Temp/eoiF0A0.tmp//plugins/org.eclipse.justj.openjdk.hotspot.jre.minimal.stripped.win32.x86_64_17.0.9.v20231028-0858/jre/bin/server;C:/Users/marco/AppData/Local/Temp/eoiF0A0.tmp//plugins/org.eclipse.justj.openjdk.hotspot.jre.minimal.stripped.win32.x86_64_17.0.9.v20231028-0858/jre/bin;C:\Program Files\Google\Chrome\Application;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\Git\cmd;C:\Program Files\nodejs\;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Users\marco\AppData\Local\Programs\Python\Launcher\;C:\Program Files\MySQL\MySQL Shell 8.0\bin\;C:\Users\marco\AppData\Local\Microsoft\WindowsApps;C:\Users\marco\AppData\Local\GitHubDesktop\bin;C:\Users\marco\AppData\Local\Programs\Microsoft VS Code\bin;C:\Users\marco\AppData\Roaming\npm;C:\Users\marco\Downloads;;C:\Users\marco\Downloads]

Info: Nothing to build for 1 liste
19:42:12 **** Rebuild of configuration Debug for project Lab3 ****
Info: Configuration "Debug" uses tool-chain "MinGW GCC" that is unsupported on this system, attempting to build anyway.
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testmatrice.o" "..\\src\\testmatrice.cpp" 
Cannot run program "g++": Launching failed

Error: Program "g++" not found in PATH
PATH=[\bin;\bin;\usr\bin;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin/server;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\Git\cmd;C:\Program Files\nodejs\;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Users\marco\AppData\Local\Programs\Python\Launcher\;C:\Program Files\MySQL\MySQL Shell 8.0\bin\;C:\Users\marco\AppData\Local\Microsoft\WindowsApps;C:\Users\marco\AppData\Local\GitHubDesktop\bin;C:\Users\marco\AppData\Local\Programs\Microsoft VS Code\bin;C:\Users\marco\AppData\Roaming\npm;C:\WINDOWS\system32]

19:42:12 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Configuration "Debug" uses tool-chain "MinGW GCC" that is unsupported on this system, attempting to build anyway.
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
Cannot run program "g++": Launching failed

Error: Program "g++" not found in PATH
PATH=[\bin;\bin;\usr\bin;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin/server;C:/Users/marco/.p2/pool/plugins/org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.9.v20231028-0858/jre/bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\Git\cmd;C:\Program Files\nodejs\;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Users\marco\AppData\Local\Programs\Python\Launcher\;C:\Program Files\MySQL\MySQL Shell 8.0\bin\;C:\Users\marco\AppData\Local\Microsoft\WindowsApps;C:\Users\marco\AppData\Local\GitHubDesktop\bin;C:\Users\marco\AppData\Local\Programs\Microsoft VS Code\bin;C:\Users\marco\AppData\Roaming\npm;C:\WINDOWS\system32]

Info: Nothing to build for 1 liste
Info: Nothing to build for Lab3
19:44:27 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:36:7: error: extra qualification 'listaPuntatore<T>::' on member 'inverti' [-fpermissive]
  void listaPuntatore<T>::inverti();
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:36:34: error: explicit specialization of 'void listaPuntatore<T>::inverti()' must be introduced by 'template <>'
  void listaPuntatore<T>::inverti();
                                  ^
..\src\listapuntatore.h:37:7: error: extra qualification 'listaPuntatore<T>::' on member 'palindroma' [-fpermissive]
  bool listaPuntatore<T>::palindroma() const;
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:37:39: error: explicit specialization of 'bool listaPuntatore<T>::palindroma() const' must be introduced by 'template <>'
  bool listaPuntatore<T>::palindroma() const;
                                       ^~~~~
..\src\listapuntatore.cpp:190:38: error: no 'bool listaPuntatore<T>::palindroma() const' member function declared in class 'listaPuntatore<T>'
 bool listaPuntatore<T>::palindroma() const {
                                      ^~~~~
..\src\listapuntatore.cpp:212:33: error: no 'void listaPuntatore<T>::inverti()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::inverti() {
                                 ^
19:45:40 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:36:7: error: extra qualification 'listaPuntatore<T>::' on member 'inverti' [-fpermissive]
  void listaPuntatore<T>::inverti();
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:36:34: error: explicit specialization of 'void listaPuntatore<T>::inverti()' must be introduced by 'template <>'
  void listaPuntatore<T>::inverti();
                                  ^
..\src\listapuntatore.h:37:7: error: extra qualification 'listaPuntatore<T>::' on member 'palindroma' [-fpermissive]
  bool listaPuntatore<T>::palindroma() const;
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:37:39: error: explicit specialization of 'bool listaPuntatore<T>::palindroma() const' must be introduced by 'template <>'
  bool listaPuntatore<T>::palindroma() const;
                                       ^~~~~
..\src\listapuntatore.cpp:190:38: error: no 'bool listaPuntatore<T>::palindroma() const' member function declared in class 'listaPuntatore<T>'
 bool listaPuntatore<T>::palindroma() const {
                                      ^~~~~
..\src\listapuntatore.cpp:212:33: error: no 'void listaPuntatore<T>::inverti()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::inverti() {
                                 ^
19:48:44 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:1:28: warning: extra tokens at end of #include directive
 #include "listapuntatore.h";
                            ^
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:36:7: error: extra qualification 'listaPuntatore<T>::' on member 'inverti' [-fpermissive]
  void listaPuntatore<T>::inverti();
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:36:34: error: explicit specialization of 'void listaPuntatore<T>::inverti()' must be introduced by 'template <>'
  void listaPuntatore<T>::inverti();
                                  ^
..\src\listapuntatore.h:37:7: error: extra qualification 'listaPuntatore<T>::' on member 'palindroma' [-fpermissive]
  bool listaPuntatore<T>::palindroma() const;
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:37:39: error: explicit specialization of 'bool listaPuntatore<T>::palindroma() const' must be introduced by 'template <>'
  bool listaPuntatore<T>::palindroma() const;
                                       ^~~~~
..\src\listapuntatore.cpp:190:38: error: no 'bool listaPuntatore<T>::palindroma() const' member function declared in class 'listaPuntatore<T>'
 bool listaPuntatore<T>::palindroma() const {
                                      ^~~~~
..\src\listapuntatore.cpp:212:33: error: no 'void listaPuntatore<T>::inverti()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::inverti() {
                                 ^
19:50:17 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:36:7: error: extra qualification 'listaPuntatore<T>::' on member 'inverti' [-fpermissive]
  void listaPuntatore<T>::inverti();
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:36:34: error: explicit specialization of 'void listaPuntatore<T>::inverti()' must be introduced by 'template <>'
  void listaPuntatore<T>::inverti();
                                  ^
..\src\listapuntatore.h:37:7: error: extra qualification 'listaPuntatore<T>::' on member 'palindroma' [-fpermissive]
  bool listaPuntatore<T>::palindroma() const;
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:37:39: error: explicit specialization of 'bool listaPuntatore<T>::palindroma() const' must be introduced by 'template <>'
  bool listaPuntatore<T>::palindroma() const;
                                       ^~~~~
..\src\listapuntatore.cpp:190:38: error: no 'bool listaPuntatore<T>::palindroma() const' member function declared in class 'listaPuntatore<T>'
 bool listaPuntatore<T>::palindroma() const {
                                      ^~~~~
..\src\listapuntatore.cpp:212:33: error: no 'void listaPuntatore<T>::inverti()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::inverti() {
                                 ^
19:50:28 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:36:7: error: extra qualification 'listaPuntatore<T>::' on member 'inverti' [-fpermissive]
  void listaPuntatore<T>::inverti();
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:36:34: error: explicit specialization of 'void listaPuntatore<T>::inverti()' must be introduced by 'template <>'
  void listaPuntatore<T>::inverti();
                                  ^
..\src\listapuntatore.h:37:7: error: extra qualification 'listaPuntatore<T>::' on member 'palindroma' [-fpermissive]
  bool listaPuntatore<T>::palindroma() const;
       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:37:39: error: explicit specialization of 'bool listaPuntatore<T>::palindroma() const' must be introduced by 'template <>'
  bool listaPuntatore<T>::palindroma() const;
                                       ^~~~~
..\src\listapuntatore.cpp:190:38: error: no 'bool listaPuntatore<T>::palindroma() const' member function declared in class 'listaPuntatore<T>'
 bool listaPuntatore<T>::palindroma() const {
                                      ^~~~~
..\src\listapuntatore.cpp:212:33: error: no 'void listaPuntatore<T>::inverti()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::inverti() {
                                 ^
19:51:31 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -o Lab5.exe "src\\listapuntatore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
19:51:35 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -o Lab5.exe "src\\listapuntatore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
20:37:23 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listavettore.o" "..\\src\\listavettore.cpp" 
..\src\listavettore.cpp:1:26: warning: extra tokens at end of #include directive
 #include "listavettore.h";
                          ^
g++ -o "1 liste.exe" "src\\listapuntatore.o" "src\\listavettore.o" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
20:37:25 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
..\src\listaordinata.cpp:12:59: error: no 'void listaOrdinata<T>::inserisciOrdinato(const T&)' member function declared in class 'listaOrdinata<T>'
 void listaOrdinata<T>::inserisciOrdinato(const T& elemento) {
                                                           ^
..\src\listaordinata.cpp:23:57: error: no 'void listaOrdinata<T>::rimuoviOrdinato(const T&)' member function declared in class 'listaOrdinata<T>'
 void listaOrdinata<T>::rimuoviOrdinato(const T& elemento) {
                                                         ^
..\src\listaordinata.cpp:32:90: error: no 'typename listaPuntatore<T>::posizione listaOrdinata<T>::cercaElemento(const T&) const' member function declared in class 'listaOrdinata<T>'
 typename listaPuntatore<T>::posizione listaOrdinata<T>::cercaElemento(const T& elemento) const {
                                                                                          ^~~~~
..\src\listaordinata.cpp:75:82: error: no 'listaOrdinata<T> listaOrdinata<T>::fondaListeOrdinate(const listaOrdinata<T>&) const' member function declared in class 'listaOrdinata<T>'
 listaOrdinata<T> listaOrdinata<T>::fondaListeOrdinate(const listaOrdinata<T>& l) const {
                                                                                  ^~~~~
Info: Nothing to build for 1 liste
20:39:18 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
..\src\listaordinata.cpp:12:59: error: no 'void listaOrdinata<T>::inserisciOrdinato(const T&)' member function declared in class 'listaOrdinata<T>'
 void listaOrdinata<T>::inserisciOrdinato(const T& elemento) {
                                                           ^
..\src\listaordinata.cpp:23:57: error: no 'void listaOrdinata<T>::rimuoviOrdinato(const T&)' member function declared in class 'listaOrdinata<T>'
 void listaOrdinata<T>::rimuoviOrdinato(const T& elemento) {
                                                         ^
..\src\listaordinata.cpp:60:82: error: no 'listaOrdinata<T> listaOrdinata<T>::fondaListeOrdinate(const listaOrdinata<T>&) const' member function declared in class 'listaOrdinata<T>'
 listaOrdinata<T> listaOrdinata<T>::fondaListeOrdinate(const listaOrdinata<T>& l) const {
                                                                                  ^~~~~
Info: Nothing to build for 1 liste
20:39:49 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -o Lab5.exe "src\\listaordinata.o" "src\\listapuntatore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for 1 liste
20:41:10 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
g++ -o Lab5.exe "src\\listaordinata.o" "src\\listapuntatore.o" "src\\test.o" 
src\test.o: In function `main':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:8: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:8: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:9: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:9: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:10: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:10: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:11: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:11: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:17: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:23: undefined reference to `listaOrdinata<int>::inserisciOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:28: undefined reference to `listaOrdinata<int>::rimuoviOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:34: undefined reference to `listaPuntatore<int>::cercaElemento(int) const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:43: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:43: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:44: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:44: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:45: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:45: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:47: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:51: undefined reference to `listaOrdinata<int>::fondaListeOrdinate(listaOrdinata<int> const&) const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
src\test.o: In function `ZN13listaOrdinataIiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/listaordinata.h:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x8): undefined reference to `listaPuntatore<int>::creaLista()'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0xc): undefined reference to `listaPuntatore<int>::listaVuota() const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x10): undefined reference to `listaPuntatore<int>::leggiLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x14): undefined reference to `listaPuntatore<int>::scriviLista(int, nodo<int>*)'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x18): undefined reference to `listaPuntatore<int>::primoLista() const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x1c): undefined reference to `listaPuntatore<int>::fineLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x20): undefined reference to `listaPuntatore<int>::succLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x24): undefined reference to `listaPuntatore<int>::predLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x28): undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x2c): undefined reference to `listaPuntatore<int>::cancLista(nodo<int>*)'
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for 1 liste
20:41:22 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -o Lab5.exe "src\\listaordinata.o" "src\\listapuntatore.o" "src\\test.o" 
src\test.o: In function `main':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:8: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:8: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:9: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:9: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:10: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:10: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:11: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:11: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:17: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:23: undefined reference to `listaOrdinata<int>::inserisciOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:28: undefined reference to `listaOrdinata<int>::rimuoviOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:34: undefined reference to `listaPuntatore<int>::cercaElemento(int) const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:43: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:43: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:44: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:44: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:45: undefined reference to `listaPuntatore<int>::primoLista() const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:45: undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:47: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:51: undefined reference to `listaOrdinata<int>::fondaListeOrdinate(listaOrdinata<int> const&) const'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:42: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
src\test.o: In function `ZN13listaOrdinataIiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/listaordinata.h:7: undefined reference to `listaPuntatore<int>::~listaPuntatore()'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x8): undefined reference to `listaPuntatore<int>::creaLista()'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0xc): undefined reference to `listaPuntatore<int>::listaVuota() const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x10): undefined reference to `listaPuntatore<int>::leggiLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x14): undefined reference to `listaPuntatore<int>::scriviLista(int, nodo<int>*)'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x18): undefined reference to `listaPuntatore<int>::primoLista() const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x1c): undefined reference to `listaPuntatore<int>::fineLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x20): undefined reference to `listaPuntatore<int>::succLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x24): undefined reference to `listaPuntatore<int>::predLista(nodo<int>*) const'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x28): undefined reference to `listaPuntatore<int>::insLista(int, nodo<int>*)'
src\test.o:test.cpp:(.rdata$_ZTV13listaOrdinataIiE[__ZTV13listaOrdinataIiE]+0x2c): undefined reference to `listaPuntatore<int>::cancLista(nodo<int>*)'
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for 1 liste
20:41:59 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:48: error: 'Nodo' was not declared in this scope
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
                                                ^~~~
..\src\listaordinata.h:7:54: error: wrong number of template arguments (2, should be 1)
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
                                                      ^
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1:
..\src\listapuntatore.h:13:7: note: provided for 'template<class T> class listaPuntatore'
 class listaPuntatore : public listaLineare<T, nodo<T>*>{
       ^~~~~~~~~~~~~~
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:55: error: expected '{' before '*' token
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
                                                       ^
..\src\listaordinata.cpp:4:59: error: invalid use of incomplete type 'class listaOrdinata<T>'
 listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>& l) {
                                                           ^
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:7: note: declaration of 'class listaOrdinata<T>'
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
       ^~~~~~~~~~~~~
..\src\listaordinata.cpp:12:59: error: invalid use of incomplete type 'class listaOrdinata<T>'
 void listaOrdinata<T>::inserisciOrdinato(const T& elemento) {
                                                           ^
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:7: note: declaration of 'class listaOrdinata<T>'
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
       ^~~~~~~~~~~~~
..\src\listaordinata.cpp:23:57: error: invalid use of incomplete type 'class listaOrdinata<T>'
 void listaOrdinata<T>::rimuoviOrdinato(const T& elemento) {
                                                         ^
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:7: note: declaration of 'class listaOrdinata<T>'
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
       ^~~~~~~~~~~~~
..\src\listaordinata.cpp:32:36: error: invalid use of incomplete type 'class listaOrdinata<T>'
 void listaOrdinata<T>::ordinaLista() {
                                    ^
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:7: note: declaration of 'class listaOrdinata<T>'
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
       ^~~~~~~~~~~~~
..\src\listaordinata.cpp:60:82: error: invalid use of incomplete type 'class listaOrdinata<T>'
 listaOrdinata<T> listaOrdinata<T>::fondaListeOrdinate(const listaOrdinata<T>& l) const {
                                                                                  ^~~~~
In file included from ..\src\listaordinata.cpp:1:0:
..\src\listaordinata.h:7:7: note: declaration of 'class listaOrdinata<T>'
 class listaOrdinata : public listaPuntatore<T, Nodo<T>*> {
       ^~~~~~~~~~~~~
Info: Nothing to build for 1 liste
20:42:28 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -o Lab5.exe "src\\listaordinata.o" "src\\listapuntatore.o" "src\\test.o" 
src\test.o: In function `main':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:17: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:23: undefined reference to `listaOrdinata<int>::inserisciOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:28: undefined reference to `listaOrdinata<int>::rimuoviOrdinato(int const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:47: undefined reference to `listaOrdinata<int>::listaOrdinata(listaPuntatore<int> const&)'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Lab5\Debug/../src/test.cpp:51: undefined reference to `listaOrdinata<int>::fondaListeOrdinate(listaOrdinata<int> const&) const'
collect2.exe: error: ld returned 1 exit status
Info: Nothing to build for 1 liste
20:43:01 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:6:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore()'
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:6:1: note: 'listaPuntatore<T>::listaPuntatore()' previously declared here
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:12:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)'
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:12:1: note: 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)' previously declared here
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:19:1: error: redefinition of 'listaPuntatore<T>::~listaPuntatore()'
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:19:1: note: 'listaPuntatore<T>::~listaPuntatore()' previously declared here
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:32:6: error: redefinition of 'void listaPuntatore<T>::creaLista()'
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: 'void listaPuntatore<T>::creaLista()' previously declared here
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:41:6: error: redefinition of 'bool listaPuntatore<T>::listaVuota() const'
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:41:6: note: 'bool listaPuntatore<T>::listaVuota() const' previously declared here
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:47:38: error: redefinition of 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:47:38: note: 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:58:6: error: redefinition of 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:58:6: note: 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:69:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:69:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:75:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:75:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:81:6: error: redefinition of 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const'
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:81:6: note: 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const' previously declared here
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:87:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:87:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:93:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:93:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:99:6: error: redefinition of 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:99:6: note: 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:129:6: error: redefinition of 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:129:6: note: 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:145:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:145:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:158:5: error: redefinition of 'int listaPuntatore<T>::lunghezzaLista() const'
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:158:5: note: 'int listaPuntatore<T>::lunghezzaLista() const' previously declared here
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:165:6: error: redefinition of 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:165:6: note: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:190:6: error: redefinition of 'bool listaPuntatore<T>::palindroma() const'
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:190:6: note: 'bool listaPuntatore<T>::palindroma() const' previously declared here
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:212:6: error: redefinition of 'void listaPuntatore<T>::inverti()'
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:212:6: note: 'void listaPuntatore<T>::inverti()' previously declared here
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:230:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:230:6: note: 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:235:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:235:6: note: 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:240:6: error: redefinition of 'void listaPuntatore<T>::rimuoviTesta()'
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:240:6: note: 'void listaPuntatore<T>::rimuoviTesta()' previously declared here
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:247:6: error: redefinition of 'void listaPuntatore<T>::rimuoviCoda()'
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:247:6: note: 'void listaPuntatore<T>::rimuoviCoda()' previously declared here
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:254:6: error: redefinition of 'void listaPuntatore<T>::svuotaLista()'
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:254:6: note: 'void listaPuntatore<T>::svuotaLista()' previously declared here
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:11: error: 'nodo<int>* listaPuntatore<int>::lista' is private within this context
     this->lista = l.lista;
     ~~~~~~^~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:60:12: note: declared private here
  posizione lista;
            ^~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:6:21: error: 'nodo<int>* listaPuntatore<int>::lista' is private within this context
     this->lista = l.lista;
                   ~~^~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:60:12: note: declared private here
  posizione lista;
            ^~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:7:11: error: 'int listaPuntatore<int>::lunghezza' is private within this context
     this->lunghezza = l.lunghezza;
     ~~~~~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:7:25: error: 'int listaPuntatore<int>::lunghezza' is private within this context
     this->lunghezza = l.lunghezza;
                       ~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
Info: Nothing to build for 1 liste
20:44:17 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:6:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore()'
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:6:1: note: 'listaPuntatore<T>::listaPuntatore()' previously declared here
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:12:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)'
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:12:1: note: 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)' previously declared here
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:19:1: error: redefinition of 'listaPuntatore<T>::~listaPuntatore()'
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:19:1: note: 'listaPuntatore<T>::~listaPuntatore()' previously declared here
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:32:6: error: redefinition of 'void listaPuntatore<T>::creaLista()'
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: 'void listaPuntatore<T>::creaLista()' previously declared here
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:41:6: error: redefinition of 'bool listaPuntatore<T>::listaVuota() const'
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:41:6: note: 'bool listaPuntatore<T>::listaVuota() const' previously declared here
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:47:38: error: redefinition of 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:47:38: note: 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:58:6: error: redefinition of 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:58:6: note: 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:69:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:69:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:75:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:75:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:81:6: error: redefinition of 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const'
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:81:6: note: 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const' previously declared here
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:87:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:87:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:93:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:93:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:99:6: error: redefinition of 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:99:6: note: 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:129:6: error: redefinition of 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:129:6: note: 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:145:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:145:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:158:5: error: redefinition of 'int listaPuntatore<T>::lunghezzaLista() const'
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:158:5: note: 'int listaPuntatore<T>::lunghezzaLista() const' previously declared here
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:165:6: error: redefinition of 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:165:6: note: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:190:6: error: redefinition of 'bool listaPuntatore<T>::palindroma() const'
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:190:6: note: 'bool listaPuntatore<T>::palindroma() const' previously declared here
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:212:6: error: redefinition of 'void listaPuntatore<T>::inverti()'
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:212:6: note: 'void listaPuntatore<T>::inverti()' previously declared here
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:230:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:230:6: note: 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:235:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:235:6: note: 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:240:6: error: redefinition of 'void listaPuntatore<T>::rimuoviTesta()'
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:240:6: note: 'void listaPuntatore<T>::rimuoviTesta()' previously declared here
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:247:6: error: redefinition of 'void listaPuntatore<T>::rimuoviCoda()'
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:247:6: note: 'void listaPuntatore<T>::rimuoviCoda()' previously declared here
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:254:6: error: redefinition of 'void listaPuntatore<T>::svuotaLista()'
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:254:6: note: 'void listaPuntatore<T>::svuotaLista()' previously declared here
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:21: error: 'nodo<int>* listaPuntatore<int>::lista' is protected within this context
     this->lista = l.lista;
                   ~~^~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:60:12: note: declared protected here
  posizione lista;
            ^~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:7:25: error: 'int listaPuntatore<int>::lunghezza' is protected within this context
     this->lunghezza = l.lunghezza;
                       ~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared protected here
  int lunghezza;
      ^~~~~~~~~
Info: Nothing to build for 1 liste
20:44:58 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:6:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore()'
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:6:1: note: 'listaPuntatore<T>::listaPuntatore()' previously declared here
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:12:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)'
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:12:1: note: 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)' previously declared here
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:19:1: error: redefinition of 'listaPuntatore<T>::~listaPuntatore()'
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:19:1: note: 'listaPuntatore<T>::~listaPuntatore()' previously declared here
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:32:6: error: redefinition of 'void listaPuntatore<T>::creaLista()'
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: 'void listaPuntatore<T>::creaLista()' previously declared here
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:41:6: error: redefinition of 'bool listaPuntatore<T>::listaVuota() const'
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:41:6: note: 'bool listaPuntatore<T>::listaVuota() const' previously declared here
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:47:38: error: redefinition of 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:47:38: note: 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:58:6: error: redefinition of 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:58:6: note: 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:69:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:69:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:75:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:75:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:81:6: error: redefinition of 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const'
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:81:6: note: 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const' previously declared here
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:87:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:87:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:93:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:93:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:99:6: error: redefinition of 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:99:6: note: 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:129:6: error: redefinition of 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:129:6: note: 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:145:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:145:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:158:5: error: redefinition of 'int listaPuntatore<T>::lunghezzaLista() const'
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:158:5: note: 'int listaPuntatore<T>::lunghezzaLista() const' previously declared here
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:165:6: error: redefinition of 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:165:6: note: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:190:6: error: redefinition of 'bool listaPuntatore<T>::palindroma() const'
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:190:6: note: 'bool listaPuntatore<T>::palindroma() const' previously declared here
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:212:6: error: redefinition of 'void listaPuntatore<T>::inverti()'
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:212:6: note: 'void listaPuntatore<T>::inverti()' previously declared here
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:230:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:230:6: note: 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:235:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:235:6: note: 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:240:6: error: redefinition of 'void listaPuntatore<T>::rimuoviTesta()'
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:240:6: note: 'void listaPuntatore<T>::rimuoviTesta()' previously declared here
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:247:6: error: redefinition of 'void listaPuntatore<T>::rimuoviCoda()'
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:247:6: note: 'void listaPuntatore<T>::rimuoviCoda()' previously declared here
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaordinata.h:4:0,
                 from ..\src\listaordinata.cpp:1,
                 from ..\src\test.cpp:3:
..\src\listapuntatore.cpp:254:6: error: redefinition of 'void listaPuntatore<T>::svuotaLista()'
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:254:6: note: 'void listaPuntatore<T>::svuotaLista()' previously declared here
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:7:21: error: 'nodo<int>* listaPuntatore<int>::lista' is protected within this context
     this->lista = l.lista;
                   ~~^~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:60:12: note: declared protected here
  posizione lista;
            ^~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:8:25: error: 'int listaPuntatore<int>::lunghezza' is protected within this context
     this->lunghezza = l.lunghezza;
                       ~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared protected here
  int lunghezza;
      ^~~~~~~~~
Info: Nothing to build for 1 liste
20:45:36 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:7:21: error: 'nodo<int>* listaPuntatore<int>::lista' is protected within this context
     this->lista = l.lista;
                   ~~^~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:60:12: note: declared protected here
  posizione lista;
            ^~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp:8:25: error: 'int listaPuntatore<int>::lunghezza' is protected within this context
     this->lunghezza = l.lunghezza;
                       ~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared protected here
  int lunghezza;
      ^~~~~~~~~
Info: Nothing to build for 1 liste
20:48:33 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:5: error: no matching function for call to 'listaOrdinata<int>::creaLista(const listaPuntatore<int>&)'
     this->creaLista(l);
     ^~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: candidate: void listaPuntatore<T>::creaLista() [with T = int]
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: note:   candidate expects 0 arguments, 1 provided
Info: Nothing to build for 1 liste
20:48:49 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
..\src\listaordinata.cpp: In constructor 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&)':
..\src\listaordinata.cpp:6:23: error: expected primary-expression before ')' token
     this->creaLista(l*);
                       ^
Info: Nothing to build for 1 liste
20:49:00 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:5: error: no matching function for call to 'listaOrdinata<int>::creaLista(const listaPuntatore<int>*)'
     this->creaLista(&l);
     ^~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: candidate: void listaPuntatore<T>::creaLista() [with T = int]
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: note:   candidate expects 0 arguments, 1 provided
Info: Nothing to build for 1 liste
20:49:07 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:5: error: no matching function for call to 'listaOrdinata<int>::creaLista(const listaPuntatore<int>&)'
     this->creaLista(l);
     ^~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: candidate: void listaPuntatore<T>::creaLista() [with T = int]
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: note:   candidate expects 0 arguments, 1 provided
Info: Nothing to build for 1 liste
20:49:23 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:5: error: no matching function for call to 'listaOrdinata<int>::creaLista(const listaPuntatore<int>&)'
     this->creaLista(l);
     ^~~~
In file included from ..\src\test.cpp:2:0:
..\src\listapuntatore.cpp:32:6: note: candidate: void listaPuntatore<T>::creaLista() [with T = int]
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: note:   candidate expects 0 arguments, 1 provided
Info: Nothing to build for 1 liste
20:51:41 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:5: error: base operand of '->' has non-pointer type 'const listaPuntatore<int>'
     l->ordinaLista();
     ^
Info: Nothing to build for 1 liste
20:52:01 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'listaOrdinata<T>::listaOrdinata(const listaPuntatore<T>&) [with T = int]':
..\src\test.cpp:17:37:   required from here
..\src\listaordinata.cpp:6:23: error: base operand of '->' has non-pointer type 'const listaPuntatore<int>'
     (listaOrdinata<T>)l->ordinaLista();
                       ^
Info: Nothing to build for 1 liste
20:54:39 **** Incremental Build of configuration Debug for project Lab5 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listaordinata.o" "..\\src\\listaordinata.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\test.o" "..\\src\\test.cpp" 
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'void listaOrdinata<T>::inserisciOrdinato(const T&) [with T = int]':
..\src\test.cpp:23:31:   required from here
..\src\listaordinata.cpp:24:11: error: 'int listaPuntatore<int>::lunghezza' is private within this context
     this->lunghezza++;
     ~~~~~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
In file included from ..\src\test.cpp:3:0:
..\src\listaordinata.cpp: In instantiation of 'void listaOrdinata<T>::rimuoviOrdinato(const T&) [with T = int]':
..\src\test.cpp:28:29:   required from here
..\src\listaordinata.cpp:33:15: error: 'int listaPuntatore<int>::lunghezza' is private within this context
         this->lunghezza--;
         ~~~~~~^~~~~~~~~
In file included from ..\src\listapuntatore.cpp:1:0,
                 from ..\src\test.cpp:2:
..\src\listapuntatore.h:61:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
21:23:01 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listavettore.o" "..\\src\\listavettore.cpp" 
..\src\listavettore.cpp:1:26: warning: extra tokens at end of #include directive
 #include "listavettore.h";
                          ^
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -o "1 liste.exe" "src\\listapuntatore.o" "src\\listavettore.o" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
21:23:02 **** Rebuild of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
..\src\listapuntatore.cpp:276:65: error: no 'int listaPuntatore<T>::num_elements(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione) const' member function declared in class 'listaPuntatore<T>'
 int listaPuntatore<T>::num_elements(posizione p1, posizione p2) const {
                                                                 ^~~~~
..\src\listapuntatore.cpp:287:60: error: no 'void listaPuntatore<T>::exchange(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::exchange(posizione p1, posizione p2) {
                                                            ^
..\src\listapuntatore.cpp:296:38: error: no 'void listaPuntatore<T>::move_min_max()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::move_min_max() {
                                      ^
..\src\listapuntatore.cpp:328:39: error: no 'void listaPuntatore<T>::insertionSort()' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::insertionSort() {
                                       ^
Info: Nothing to build for 1 liste
21:25:25 **** Incremental Build of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:51:7: error: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' cannot be overloaded
  bool operator==(const listaPuntatore<T>&) const;
       ^~~~~~~~
..\src\listapuntatore.h:42:10: error: with 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
     bool operator==(const listaPuntatore<T>&) const;
          ^~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
..\src\listapuntatore.cpp:6:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore()'
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:6:1: note: 'listaPuntatore<T>::listaPuntatore()' previously declared here
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:12:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)'
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:12:1: note: 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)' previously declared here
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:19:1: error: redefinition of 'listaPuntatore<T>::~listaPuntatore()'
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:19:1: note: 'listaPuntatore<T>::~listaPuntatore()' previously declared here
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: error: redefinition of 'void listaPuntatore<T>::creaLista()'
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:32:6: note: 'void listaPuntatore<T>::creaLista()' previously declared here
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:41:6: error: redefinition of 'bool listaPuntatore<T>::listaVuota() const'
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:41:6: note: 'bool listaPuntatore<T>::listaVuota() const' previously declared here
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:47:38: error: redefinition of 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:47:38: note: 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:58:6: error: redefinition of 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:58:6: note: 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:69:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:69:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:75:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:75:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:81:6: error: redefinition of 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const'
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:81:6: note: 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const' previously declared here
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:87:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:87:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:93:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:93:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:99:6: error: redefinition of 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:99:6: note: 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:129:6: error: redefinition of 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:129:6: note: 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:145:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:145:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:158:5: error: redefinition of 'int listaPuntatore<T>::lunghezzaLista() const'
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:158:5: note: 'int listaPuntatore<T>::lunghezzaLista() const' previously declared here
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:165:6: error: redefinition of 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:165:6: note: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:189:6: error: redefinition of 'bool listaPuntatore<T>::operator!=(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator!=(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:189:6: note: 'bool listaPuntatore<T>::operator!=(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator!=(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:195:6: error: redefinition of 'bool listaPuntatore<T>::palindroma() const'
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:195:6: note: 'bool listaPuntatore<T>::palindroma() const' previously declared here
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:217:6: error: redefinition of 'void listaPuntatore<T>::inverti()'
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:217:6: note: 'void listaPuntatore<T>::inverti()' previously declared here
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:235:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:235:6: note: 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:240:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:240:6: note: 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:245:6: error: redefinition of 'void listaPuntatore<T>::rimuoviTesta()'
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:245:6: note: 'void listaPuntatore<T>::rimuoviTesta()' previously declared here
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:252:6: error: redefinition of 'void listaPuntatore<T>::rimuoviCoda()'
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:252:6: note: 'void listaPuntatore<T>::rimuoviCoda()' previously declared here
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:259:6: error: redefinition of 'void listaPuntatore<T>::svuotaLista()'
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:259:6: note: 'void listaPuntatore<T>::svuotaLista()' previously declared here
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
..\src\listapuntatore.cpp:276:5: error: redefinition of 'int listaPuntatore<T>::num_elements(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione) const'
 int listaPuntatore<T>::num_elements(posizione p1, posizione p2) const {
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:276:5: note: 'int listaPuntatore<T>::num_elements(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione) const' previously declared here
 int listaPuntatore<T>::num_elements(posizione p1, posizione p2) const {
     ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:287:6: error: redefinition of 'void listaPuntatore<T>::exchange(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::exchange(posizione p1, posizione p2) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:287:6: note: 'void listaPuntatore<T>::exchange(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::exchange(posizione p1, posizione p2) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:296:6: error: redefinition of 'void listaPuntatore<T>::move_min_max()'
 void listaPuntatore<T>::move_min_max() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:296:6: note: 'void listaPuntatore<T>::move_min_max()' previously declared here
 void listaPuntatore<T>::move_min_max() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:328:6: error: redefinition of 'void listaPuntatore<T>::insertionSort()'
 void listaPuntatore<T>::insertionSort() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:74:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:328:6: note: 'void listaPuntatore<T>::insertionSort()' previously declared here
 void listaPuntatore<T>::insertionSort() {
      ^~~~~~~~~~~~~~~~~
Info: Nothing to build for 1 liste
21:25:39 **** Incremental Build of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
..\src\listapuntatore.cpp:6:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore()'
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:6:1: note: 'listaPuntatore<T>::listaPuntatore()' previously declared here
 listaPuntatore<T>::listaPuntatore (){
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:12:1: error: redefinition of 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)'
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:12:1: note: 'listaPuntatore<T>::listaPuntatore(const listaPuntatore<T>&)' previously declared here
 listaPuntatore<T>::listaPuntatore (const listaPuntatore<T>& l) {
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:19:1: error: redefinition of 'listaPuntatore<T>::~listaPuntatore()'
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:19:1: note: 'listaPuntatore<T>::~listaPuntatore()' previously declared here
 listaPuntatore<T>::~listaPuntatore() {
 ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:32:6: error: redefinition of 'void listaPuntatore<T>::creaLista()'
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:32:6: note: 'void listaPuntatore<T>::creaLista()' previously declared here
 void listaPuntatore<T>::creaLista () {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:41:6: error: redefinition of 'bool listaPuntatore<T>::listaVuota() const'
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:41:6: note: 'bool listaPuntatore<T>::listaVuota() const' previously declared here
 bool listaPuntatore<T>::listaVuota () const{
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:47:38: error: redefinition of 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:47:38: note: 'listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:58:6: error: redefinition of 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:58:6: note: 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:69:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:69:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::primoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::primoLista () const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:75:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:75:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista() const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::ultimoLista () const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:81:6: error: redefinition of 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const'
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:81:6: note: 'bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const' previously declared here
 bool listaPuntatore<T>::fineLista (typename listaPuntatore<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:87:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:87:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::succLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:93:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:93:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::predLista(listaPuntatore<T>::posizione) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::predLista (typename listaPuntatore<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:99:6: error: redefinition of 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:99:6: note: 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:129:6: error: redefinition of 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:129:6: note: 'void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::cancLista (typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:145:39: error: redefinition of 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:145:39: note: 'listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const' previously declared here
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:158:5: error: redefinition of 'int listaPuntatore<T>::lunghezzaLista() const'
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:158:5: note: 'int listaPuntatore<T>::lunghezzaLista() const' previously declared here
 int listaPuntatore<T>::lunghezzaLista() const{
     ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:165:6: error: redefinition of 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:165:6: note: 'bool listaPuntatore<T>::operator==(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator==(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:189:6: error: redefinition of 'bool listaPuntatore<T>::operator!=(const listaPuntatore<T>&) const'
 bool listaPuntatore<T>::operator!=(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:189:6: note: 'bool listaPuntatore<T>::operator!=(const listaPuntatore<T>&) const' previously declared here
 bool listaPuntatore<T>::operator!=(const listaPuntatore<T>& l) const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:195:6: error: redefinition of 'bool listaPuntatore<T>::palindroma() const'
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:195:6: note: 'bool listaPuntatore<T>::palindroma() const' previously declared here
 bool listaPuntatore<T>::palindroma() const {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:217:6: error: redefinition of 'void listaPuntatore<T>::inverti()'
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:217:6: note: 'void listaPuntatore<T>::inverti()' previously declared here
 void listaPuntatore<T>::inverti() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:235:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:235:6: note: 'void listaPuntatore<T>::aggiungiInTesta(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInTesta(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:240:6: error: redefinition of 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)'
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:240:6: note: 'void listaPuntatore<T>::aggiungiInCoda(const tipoelem&)' previously declared here
 void listaPuntatore<T>::aggiungiInCoda(const tipoelem &valore) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:245:6: error: redefinition of 'void listaPuntatore<T>::rimuoviTesta()'
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:245:6: note: 'void listaPuntatore<T>::rimuoviTesta()' previously declared here
 void listaPuntatore<T>::rimuoviTesta() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:252:6: error: redefinition of 'void listaPuntatore<T>::rimuoviCoda()'
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:252:6: note: 'void listaPuntatore<T>::rimuoviCoda()' previously declared here
 void listaPuntatore<T>::rimuoviCoda() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:259:6: error: redefinition of 'void listaPuntatore<T>::svuotaLista()'
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:259:6: note: 'void listaPuntatore<T>::svuotaLista()' previously declared here
 void listaPuntatore<T>::svuotaLista() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
..\src\listapuntatore.cpp:276:5: error: redefinition of 'int listaPuntatore<T>::num_elements(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione) const'
 int listaPuntatore<T>::num_elements(posizione p1, posizione p2) const {
     ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:276:5: note: 'int listaPuntatore<T>::num_elements(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione) const' previously declared here
 int listaPuntatore<T>::num_elements(posizione p1, posizione p2) const {
     ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:287:6: error: redefinition of 'void listaPuntatore<T>::exchange(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione)'
 void listaPuntatore<T>::exchange(posizione p1, posizione p2) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:287:6: note: 'void listaPuntatore<T>::exchange(listaPuntatore<T>::posizione, listaPuntatore<T>::posizione)' previously declared here
 void listaPuntatore<T>::exchange(posizione p1, posizione p2) {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:296:6: error: redefinition of 'void listaPuntatore<T>::move_min_max()'
 void listaPuntatore<T>::move_min_max() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:296:6: note: 'void listaPuntatore<T>::move_min_max()' previously declared here
 void listaPuntatore<T>::move_min_max() {
      ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.cpp:328:6: error: redefinition of 'void listaPuntatore<T>::insertionSort()'
 void listaPuntatore<T>::insertionSort() {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\listapuntatore.h:73:0,
                 from ..\src\listapuntatore.cpp:1:
..\src\listapuntatore.cpp:328:6: note: 'void listaPuntatore<T>::insertionSort()' previously declared here
 void listaPuntatore<T>::insertionSort() {
      ^~~~~~~~~~~~~~~~~
Info: Nothing to build for 1 liste
21:28:26 **** Incremental Build of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
Info: Nothing to build for 1 liste
21:29:17 **** Incremental Build of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
In file included from ..\src\listapuntatore.cpp:1:0:
..\src\listapuntatore.h:50:10: error: extra qualification 'listaPuntatore<T>::' on member 'eliminaDallaLista' [-fpermissive]
     void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare);
          ^~~~~~~~~~~~~~~~~
..\src\listapuntatore.h:50:88: error: explicit specialization of 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' must be introduced by 'template <>'
     void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare);
                                                                                        ^
..\src\listapuntatore.cpp:266:84: error: no 'void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>&)' member function declared in class 'listaPuntatore<T>'
 void listaPuntatore<T>::eliminaDallaLista(const listaPuntatore<T>& listaDaEliminare) {
                                                                                    ^
Info: Nothing to build for 1 liste
21:29:52 **** Incremental Build of configuration Debug for project Lab7 ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -o Lab7.exe "src\\listapuntatore.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
23:07:32 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for 6 dizionari
23:09:52 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\listapuntatore.o" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashaperto.o: In function `ZN10hashApertoIiiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:94: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
src\testhashaperto.o: In function `ZN10hashApertoIiiE14creaDizionarioEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
collect2.exe: error: ld returned 1 exit status
23:11:18 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\listapuntatore.o" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashaperto.o: In function `ZN10hashApertoIiiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:94: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
src\testhashaperto.o: In function `ZN10hashApertoIiiE14creaDizionarioEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
collect2.exe: error: ld returned 1 exit status
23:12:35 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listapuntatore.o" "..\\src\\listapuntatore.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\listapuntatore.o" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashaperto.o: In function `ZN10hashApertoIiiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:94: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
src\testhashaperto.o: In function `ZN10hashApertoIiiE14creaDizionarioEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
collect2.exe: error: ld returned 1 exit status
23:17:15 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h: In instantiation of 'void hashAperto<K, V>::creaDizionario() [with K = int; V = int]':
..\src\hashaperto.h:81:2:   required from 'hashAperto<K, V>::hashAperto() [with K = int; V = int]'
..\src\testhashaperto.cpp:9:23:   required from here
..\src\hashaperto.h:102:13: error: cannot convert 'listaPuntatore<bucket<int, int> >*' to 'listaPuntatore<bucket<int, int>*>*' in assignment
  this->hash = new listaPuntatore<bucket<K,V>> [this->dimensione];
  ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
23:17:32 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h: In instantiation of 'void hashAperto<K, V>::inserisci(const chiave&, const valore&) [with K = int; V = int; hashAperto<K, V>::chiave = int; hashAperto<K, V>::valore = int]':
..\src\testhashaperto.cpp:11:19:   required from here
..\src\hashaperto.h:125:3: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::insLista(bucket<int, int>*&, listaPuntatore<bucket<int, int> >::posizione)'
   this->hash[pos].insLista(b, this->hash[pos].primoLista());
   ^~~~
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:29:10: note: candidate: void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = bucket<int, int>; listaPuntatore<T>::tipoelem = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     void insLista(tipoelem, posizione);
          ^~~~~~~~
..\src\listaPuntatore.h:29:10: note:   no known conversion for argument 1 from 'bucket<int, int>*' to 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h: In instantiation of 'void hashAperto<K, V>::cancella(const chiave&) [with K = int; V = int; hashAperto<K, V>::chiave = int]':
..\src\testhashaperto.cpp:22:14:   required from here
..\src\hashaperto.h:140:13: error: cannot convert 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}' to 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' in assignment
   pos_lista = this->hash[pos].primoLista();
              
..\src\hashaperto.h:141:9: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::fineLista(nodo<bucket<int, int>*>*&)'
   while(!this->hash[pos].fineLista(pos_lista) && !trovato){  // vedere se considera anche l'ultimo elemento della lista in hash[pos]
          
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:26:10: note: candidate: bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     bool fineLista(posizione) const;
          ^~~~~~~~~
..\src\listaPuntatore.h:26:10: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:142:7: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::leggiLista(nodo<bucket<int, int>*>*&)'
    if(this->hash[pos].leggiLista(pos_lista)->getChiave() != c){
       ^~~~
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:22:14: note: candidate: listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::tipoelem = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     tipoelem leggiLista(posizione) const;
              ^~~~~~~~~~
..\src\listaPuntatore.h:22:14: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:143:15: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::succLista(nodo<bucket<int, int>*>*&)'
     pos_lista = this->hash[pos].succLista(pos_lista);
                
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:27:15: note: candidate: listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     posizione succLista(posizione) const;
               ^~~~~~~~~
..\src\listaPuntatore.h:27:15: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:149:3: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::cancLista(nodo<bucket<int, int>*>*&)'
   this->hash[pos].cancLista(pos_lista);
   ^~~~
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:30:10: note: candidate: void listaPuntatore<T>::cancLista(listaPuntatore<T>::posizione) [with T = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     void cancLista(posizione);
          ^~~~~~~~~
..\src\listaPuntatore.h:30:10: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const hashAperto<int, int>&)':
..\src\testhashaperto.cpp:26:10:   required from here
..\src\hashaperto.h:46:56: error: no match for 'operator==' (operand types are 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' and 'std::nullptr_t')
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note: candidate: template<class _StateT> bool std::operator==(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::fpos<_StateT>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::pair<_T1, _T2>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note: candidate: template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator==(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::reverse_iterator<_Iterator>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator==(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::reverse_iterator<_Iterator>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator==(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::move_iterator<_IteratorL>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator==(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::move_iterator<_IteratorL>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note: candidate: template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator==(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::allocator<_CharT>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note: candidate: template<class _Tp> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator==(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::allocator<_CharT>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note: candidate: template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value, bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const std::__cxx11::basic_string<_CharT>&)
     operator==(const basic_string<_CharT>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::__cxx11::basic_string<_CharT>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   mismatched types 'const _CharT*' and 'bucket<int, int>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_code&)
   operator==(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_condition&)
   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_code&)
   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_condition&)
   operator==(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testhashaperto.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:46:56: note:   'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
     if ((d.hash[i].leggiLista(d.hash[i].primoLista())) == (nullptr)){
                                                         
..\src\hashaperto.h:52:16: error: cannot convert 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}' to 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' in assignment
      pos_lista = d.hash[i].primoLista();
                 
..\src\hashaperto.h:54:13: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::fineLista(nodo<bucket<int, int>*>*&)'
      while (!d.hash[i].fineLista(pos_lista)){
              
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:26:10: note: candidate: bool listaPuntatore<T>::fineLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     bool fineLista(posizione) const;
          ^~~~~~~~~
..\src\listaPuntatore.h:26:10: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:55:10: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::leggiLista(nodo<bucket<int, int>*>*&)'
       os << (d.hash[i].leggiLista(pos_lista)) << "   ->   ";
           
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:22:14: note: candidate: listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::tipoelem = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     tipoelem leggiLista(posizione) const;
              ^~~~~~~~~~
..\src\listaPuntatore.h:22:14: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h:56:17: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::succLista(nodo<bucket<int, int>*>*&)'
       pos_lista = d.hash[i].succLista(pos_lista);
                  
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:27:15: note: candidate: listaPuntatore<T>::posizione listaPuntatore<T>::succLista(listaPuntatore<T>::posizione) const [with T = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     posizione succLista(posizione) const;
               ^~~~~~~~~
..\src\listaPuntatore.h:27:15: note:   no known conversion for argument 1 from 'listaPuntatore<bucket<int, int>*>::posizione {aka nodo<bucket<int, int>*>*}' to 'listaPuntatore<bucket<int, int> >::posizione {aka nodo<bucket<int, int> >*}'
In file included from ..\src\testhashaperto.cpp:3:0:
..\src\hashaperto.h: In instantiation of 'void hashAperto<K, V>::creaDizionario() [with K = int; V = int]':
..\src\hashaperto.h:81:2:   required from 'hashAperto<K, V>::hashAperto() [with K = int; V = int]'
..\src\testhashaperto.cpp:9:23:   required from here
..\src\hashaperto.h:104:3: error: no matching function for call to 'listaPuntatore<bucket<int, int> >::insLista(std::nullptr_t, listaPuntatore<bucket<int, int> >::posizione)'
   this->hash[i].insLista(nullptr, this->hash[i].primoLista());
   ^~~~
In file included from ..\src\hashaperto.h:11:0,
                 from ..\src\testhashaperto.cpp:3:
..\src\listaPuntatore.h:29:10: note: candidate: void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = bucket<int, int>; listaPuntatore<T>::tipoelem = bucket<int, int>; listaPuntatore<T>::posizione = nodo<bucket<int, int> >*]
     void insLista(tipoelem, posizione);
          ^~~~~~~~
..\src\listaPuntatore.h:29:10: note:   no known conversion for argument 1 from 'std::nullptr_t' to 'listaPuntatore<bucket<int, int> >::tipoelem {aka bucket<int, int>}'
13:53:54 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\listapuntatore.o" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
src\testhashaperto.o: In function `ZN10hashApertoIiiED1Ev':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:94: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
src\testhashaperto.o: In function `ZN10hashApertoIiiE14creaDizionarioEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::listaPuntatore()'
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\6 dizionari\Debug/../src/hashaperto.h:102: undefined reference to `listaPuntatore<bucket<int, int>*>::~listaPuntatore()'
collect2.exe: error: ld returned 1 exit status
14:03:29 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for 6 dizionari
14:04:25 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for 6 dizionari
14:06:02 **** Incremental Build of configuration Debug for project 1 liste ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\listavettore.o" "..\\src\\listavettore.cpp" 
..\src\listavettore.cpp:1:26: warning: extra tokens at end of #include directive
 #include "listavettore.h";
                          ^
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testlistapuntatore.o" "..\\src\\testlistapuntatore.cpp" 
g++ -o "1 liste.exe" "src\\listavettore.o" "src\\testlistapuntatore.o" "src\\testlistavettore.o" 
14:06:04 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
14:06:20 **** Incremental Build of configuration Debug for project 6 dizionari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashchiuso.o" "..\\src\\testhashchiuso.cpp" 
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testhashaperto.o" "..\\src\\testhashaperto.cpp" 
g++ -o "6 dizionari.exe" "src\\testhashaperto.o" "src\\testhashchiuso.o" 
Info: Nothing to build for 6 dizionari
14:44:37 **** Incremental Build of configuration Debug for project 8 code_prior ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testprioricode.o" "..\\src\\testprioricode.cpp" 
In file included from ..\src\testprioricode.cpp:3:0:
..\src\prioriCode.h: In instantiation of 'prioriCoda<T>::tipoelem prioriCoda<T>::min() const [with T = int; prioriCoda<T>::tipoelem = int]':
..\src\prioriCode.h:92:30:   required from 'void prioriCoda<T>::cancellaMin() [with T = int]'
..\src\testprioricode.cpp:35:16:   required from here
..\src\prioriCode.h:82:51: error: passing 'const alberoBinArray<int>' as 'this' argument discards qualifiers [-fpermissive]
         return albero.leggiNodo(albero.binRadice());
                                                   ^
In file included from ..\src\prioriCode.h:4:0,
                 from ..\src\testprioricode.cpp:3:
..\src\alberoBinArray.h:253:38: note:   in call to 'alberoBinArray<T>::tipoelem alberoBinArray<T>::leggiNodo(alberoBinArray<T>::posizione) [with T = int; alberoBinArray<T>::tipoelem = int; alberoBinArray<T>::posizione = int]'
 typename alberoBinArray<T>::tipoelem alberoBinArray<T>::leggiNodo(typename alberoBinArray<T>::posizione p){
                                      ^~~~~~~~~~~~~~~~~
14:47:21 **** Incremental Build of configuration Debug for project 8 code_prior ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testprioricode.o" "..\\src\\testprioricode.cpp" 
In file included from ..\src\prioriCode.h:4:0,
                 from ..\src\testprioricode.cpp:3:
..\src\alberoBinArray.h: In instantiation of 'class alberoBinArray<int>':
..\src\prioriCode.h:121:6:   required from 'class prioriCoda<int>'
..\src\testprioricode.cpp:7:18:   required from here
..\src\alberoBinArray.h:183:6: error: invalid abstract parameter type 'alberoBinArray<int>'
 void alberoBinArray<T>::costrBinAlbero(alberoBinArray<T> a, typename alberoBinArray<T>::tipoelem valoreRadice){
      ^~~~~~~~~~~~~~~~~
..\src\alberoBinArray.h:12:7: note:   because the following virtual functions are pure within 'alberoBinArray<int>':
 class alberoBinArray : public alberoBinAstratto<T, int>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoBinArray.h:4:0,
                 from ..\src\prioriCode.h:4,
                 from ..\src\testprioricode.cpp:3:
..\src\alberoBinAstratto.h:19:19: note: 	alberoBinAstratto<T, P>::tipoelem alberoBinAstratto<T, P>::leggiNodo(alberoBinAstratto<T, P>::posizione) [with T = int; P = int; alberoBinAstratto<T, P>::tipoelem = int; alberoBinAstratto<T, P>::posizione = int]
  virtual tipoelem leggiNodo(posizione) = 0;
                   ^~~~~~~~~
In file included from ..\src\testprioricode.cpp:3:0:
..\src\prioriCode.h: In instantiation of 'class prioriCoda<int>':
..\src\testprioricode.cpp:7:18:   required from here
..\src\prioriCode.h:30:20: error: cannot declare field 'prioriCoda<int>::albero' to be of abstract type 'alberoBinArray<int>'
  alberoBinArray<T> albero;
                    ^~~~~~
14:49:35 **** Incremental Build of configuration Debug for project 8 code_prior ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testprioricode.o" "..\\src\\testprioricode.cpp" 
g++ -o "8 code_prior.exe" "src\\testprioricode.o" 
Info: Nothing to build for 8 code_prior
Info: Nothing to build for 5 alb_bin
Info: Nothing to build for 8 code_prior
14:50:58 **** Incremental Build of configuration Debug for project 8 code_prior ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testprioricode.o" "..\\src\\testprioricode.cpp" 
g++ -o "8 code_prior.exe" "src\\testprioricode.o" 
Info: Nothing to build for 8 code_prior
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
14:57:11 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
15:01:22 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 1 liste
15:05:47 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:243:20: error: redefinition of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&)'
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a){
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:21: note: 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&)' previously declared here
  alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                     ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:139:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:149:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:195:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:195:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:208:17: error: no match for 'operator!=' (operand types are 'nodo<alberoListaDin<int> >' and 'nodo<alberoListaDin<int> >')
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   mismatched types 'const _CharT*' and 'nodo<alberoListaDin<int> >'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:162:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:223:10: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
          this->cancSottoAlbero(this->radiceAlbero());
          ^~~~
..\src\alberoListaDin.h:182:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:230:30: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                  figlioCopia = *p;
                  ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:221:21: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
  alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                     ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:21: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:07:52 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:243:20: error: redefinition of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&)'
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a){
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:21: note: 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&)' previously declared here
  alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                     ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:139:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:149:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:195:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:195:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:208:17: error: no match for 'operator!=' (operand types are 'nodo<alberoListaDin<int> >' and 'nodo<alberoListaDin<int> >')
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   mismatched types 'const _CharT*' and 'nodo<alberoListaDin<int> >'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:162:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:223:10: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
          this->cancSottoAlbero(this->radiceAlbero());
          ^~~~
..\src\alberoListaDin.h:182:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:230:30: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                  figlioCopia = *p;
                  ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:221:21: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
  alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                     ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:21: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:12:13 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:139:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:149:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:195:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:195:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:208:17: error: no match for 'operator!=' (operand types are 'nodo<alberoListaDin<int> >' and 'nodo<alberoListaDin<int> >')
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   mismatched types 'const _CharT*' and 'nodo<alberoListaDin<int> >'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:208:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:162:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:223:10: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
          this->cancSottoAlbero(this->radiceAlbero());
          ^~~~
..\src\alberoListaDin.h:182:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:230:30: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                  figlioCopia = *p;
                  ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:221:21: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
  alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                     ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:21: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:12:56 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:107:16: error: could not convert 'temp' from 'alberoListaDin<int>*' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         return temp;
                ^~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:139:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:149:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:195:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:195:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:195:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:207:17: error: no match for 'operator!=' (operand types are 'nodo<alberoListaDin<int> >' and 'nodo<alberoListaDin<int> >')
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   mismatched types 'const _CharT*' and 'nodo<alberoListaDin<int> >'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:207:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:162:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:221:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:182:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:228:29: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                 figlioCopia = *p;
                 ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:219:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:219:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:15:40 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:104:36: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
         posizione temp(this->radice);
                                    ^
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:137:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:147:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:193:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:193:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:193:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:193:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:205:17: error: no match for 'operator!=' (operand types are 'nodo<alberoListaDin<int> >' and 'nodo<alberoListaDin<int> >')
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:444:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:304:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:361:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1125:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note: candidate: template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1131:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:158:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:164:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5097:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5110:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   mismatched types 'const _CharT*' and 'nodo<alberoListaDin<int> >'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5122:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:311:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:315:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:319:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:323:3: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:205:17: note:   'nodo<alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         if (*p1 != *p2) {
             ~~~~^~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:160:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:219:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:180:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:226:29: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                 figlioCopia = *p;
                 ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:217:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:217:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:21:13 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In destructor 'alberoListaDin<T>::~alberoListaDin()':
..\src\alberoListaDin.h:71:6: error: 'node' was not declared in this scope
  if (node) {
      ^~~~
..\src\alberoListaDin.h:75:43: error: there are no arguments to 'deallocateNodes' that depend on a template parameter, so a declaration of 'deallocateNodes' must be available [-fpermissive]
    deallocateNodes(childPos->getElemento());
                                           ^
..\src\alberoListaDin.h:75:43: note: (if you use '-fpermissive', G++ will accept your code, but allowing the use of an undeclared name is deprecated)
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::~alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:27:22:   required from here
..\src\alberoListaDin.h:75:43: error: 'deallocateNodes' was not declared in this scope
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:115:10: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
   return posizione(this->radice);
          ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:171:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  nuovaRadice->setPadre(p.radice);
  ^~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:172:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  a.radice->setPadre(nuovaRadice);
  ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:173:2: error: no matching function for call to 'listaPuntatore<alberoListaDin<int> >::insLista(nodoAlbero<int, alberoListaDin<int> >*&, listaPuntatore<alberoListaDin<int> >::posizione)'
  p.radice->getFigli().insLista(nuovaRadice, p.radice->getFigli().primoLista());
  ^
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\listaPuntatore.h:168:6: note: candidate: void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'listaPuntatore<alberoListaDin<int> >::tipoelem {aka alberoListaDin<int>}'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:147:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:157:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:205:27: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:113:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:205:27: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:205:61: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:113:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:205:61: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:217:10: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
       ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:217:45: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                          ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:14:43:   required from 'void nodo<T>::setElemento(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:129:3:   required from 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\testalberolistadin.cpp:45:1:   required from here
..\src\alberoListaDin.h:231:3: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
   this->cancSottoAlbero(this->radiceAlbero());
   ^~~~
..\src\alberoListaDin.h:192:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:238:17: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
     figlioCopia = *p;
     ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:229:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:229:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:21:19 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In destructor 'alberoListaDin<T>::~alberoListaDin()':
..\src\alberoListaDin.h:71:6: error: 'node' was not declared in this scope
  if (node) {
      ^~~~
..\src\alberoListaDin.h:75:43: error: there are no arguments to 'deallocateNodes' that depend on a template parameter, so a declaration of 'deallocateNodes' must be available [-fpermissive]
    deallocateNodes(childPos->getElemento());
                                           ^
..\src\alberoListaDin.h:75:43: note: (if you use '-fpermissive', G++ will accept your code, but allowing the use of an undeclared name is deprecated)
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::~alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:27:22:   required from here
..\src\alberoListaDin.h:75:43: error: 'deallocateNodes' was not declared in this scope
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:115:10: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
   return posizione(this->radice);
          ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:171:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  nuovaRadice->setPadre(p.radice);
  ^~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:172:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  a.radice->setPadre(nuovaRadice);
  ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:173:2: error: no matching function for call to 'listaPuntatore<alberoListaDin<int> >::insLista(nodoAlbero<int, alberoListaDin<int> >*&, listaPuntatore<alberoListaDin<int> >::posizione)'
  p.radice->getFigli().insLista(nuovaRadice, p.radice->getFigli().primoLista());
  ^
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\listaPuntatore.h:168:6: note: candidate: void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'listaPuntatore<alberoListaDin<int> >::tipoelem {aka alberoListaDin<int>}'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:147:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:157:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:205:27: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:113:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:205:27: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:205:61: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:113:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:205:61: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:217:10: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
       ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:217:45: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                          ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:14:43:   required from 'void nodo<T>::setElemento(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:129:3:   required from 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\testalberolistadin.cpp:45:1:   required from here
..\src\alberoListaDin.h:231:3: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
   this->cancSottoAlbero(this->radiceAlbero());
   ^~~~
..\src\alberoListaDin.h:192:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:238:17: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
     figlioCopia = *p;
     ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:229:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:229:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:21:28 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:120:10: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
   return posizione(this->radice);
          ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:176:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  nuovaRadice->setPadre(p.radice);
  ^~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:177:2: error: no matching function for call to 'nodoAlbero<int, alberoListaDin<int> >::setPadre(nodoAlbero<int, alberoListaDin<int> >*&)'
  a.radice->setPadre(nuovaRadice);
  ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:3:
..\src\nodoAlbero.h:23:7: note: candidate: void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]
  void setPadre (P* p) { padre = p; };
       ^~~~~~~~
..\src\nodoAlbero.h:23:7: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'alberoListaDin<int>*'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:178:2: error: no matching function for call to 'listaPuntatore<alberoListaDin<int> >::insLista(nodoAlbero<int, alberoListaDin<int> >*&, listaPuntatore<alberoListaDin<int> >::posizione)'
  p.radice->getFigli().insLista(nuovaRadice, p.radice->getFigli().primoLista());
  ^
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\listaPuntatore.h:168:6: note: candidate: void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'listaPuntatore<alberoListaDin<int> >::tipoelem {aka alberoListaDin<int>}'
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'void deallocateNodes(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:84:20:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:27:22:   required from here
..\src\alberoListaDin.h:75:28: error: no matching function for call to 'deallocateNodes(nodo<alberoListaDin<int> >::tipoelem)'
             deallocateNodes(childPos->getElemento());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:6: note: candidate: template<class T> void deallocateNodes(nodoAlbero<T, alberoListaDin<T> >*)
 void deallocateNodes(nodoAlbero<T, alberoListaDin<T>>* node) {
      ^~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:6: note:   template argument deduction/substitution failed:
..\src\alberoListaDin.h:75:28: note:   mismatched types 'nodoAlbero<T, alberoListaDin<T> >*' and 'alberoListaDin<int>'
             deallocateNodes(childPos->getElemento());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:152:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:162:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:210:27: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:118:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:210:27: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                            
..\src\alberoListaDin.h:210:61: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:118:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:210:61: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                              
..\src\alberoListaDin.h:222:10: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
       ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:222:45: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
   if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                          ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:14:43:   required from 'void nodo<T>::setElemento(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:129:3:   required from 'void listaPuntatore<T>::scriviLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\testalberolistadin.cpp:45:1:   required from here
..\src\alberoListaDin.h:236:3: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
   this->cancSottoAlbero(this->radiceAlbero());
   ^~~~
..\src\alberoListaDin.h:197:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:243:17: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
     figlioCopia = *p;
     ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:234:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:234:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:21:51 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:104:16: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
         return posizione(this->radice);
                ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:136:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:146:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:192:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:192:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:192:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:192:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:204:16: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
             ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:204:51: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                                ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:159:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:218:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:179:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:225:29: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                 figlioCopia = *p;
                 ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:216:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:216:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:23:02 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:104:41: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
      return typename alberoListaDin<T>::posizione(this->radice);    }
                                         ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:135:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:145:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:191:30: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:30: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                               
..\src\alberoListaDin.h:191:64: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:64: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
     if (this->radiceAlbero().getElemento() != a.radiceAlbero().getElemento()) {
                                                                 
..\src\alberoListaDin.h:203:16: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
             ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:203:51: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                                ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:158:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:217:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:178:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:224:29: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                 figlioCopia = *p;
                 ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:215:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:215:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:24:28 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:41:   required from here
..\src\alberoListaDin.h:104:41: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >*&)'
      return typename alberoListaDin<T>::posizione(this->radice);    }
                                         ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:135:13:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:145:21:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:42:55:   required from here
..\src\alberoListaDin.h:191:27: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento().getElemento() != a.radiceAlbero().getElemento().getElemento()) {
                            
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:27: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento().getElemento() != a.radiceAlbero().getElemento().getElemento()) {
                            
..\src\alberoListaDin.h:191:75: error: passing 'const alberoListaDin<int>' as 'this' argument discards qualifiers [-fpermissive]
  if (this->radiceAlbero().getElemento().getElemento() != a.radiceAlbero().getElemento().getElemento()) {
                                                                            
..\src\alberoListaDin.h:102:39: note:   in call to 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:75: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
  if (this->radiceAlbero().getElemento().getElemento() != a.radiceAlbero().getElemento().getElemento()) {
                                                                            
..\src\alberoListaDin.h:203:16: error: request for member 'getElemento' in 'p1', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
             ~~~^~~~~~~~~~~
..\src\alberoListaDin.h:203:51: error: request for member 'getElemento' in 'p2', which is of pointer type 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' (maybe you meant to use '->' ?)
         if (p1.getElemento()->getElemento() != p2.getElemento()->getElemento()) {
                                                ~~~^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:158:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:35:46:   required from here
..\src\alberoListaDin.h:217:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:178:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:224:29: error: no match for 'operator=' (operand types are 'alberoListaDin<int>' and 'nodo<alberoListaDin<int> >')
                 figlioCopia = *p;
                 ~~~~~~~~~~~~^~~~
..\src\alberoListaDin.h:215:20: note: candidate: alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>& a) {
                    ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:215:20: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
Info: Nothing to build for 1 liste
15:24:42 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 1 liste
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 1 liste
15:49:45 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
16:01:42 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:217:82: error: no 'void alberoListaDin<T>::distruggiAlbero(nodoAlbero<T, alberoListaDin<T> >*&)' member function declared in class 'alberoListaDin<T>'
 void alberoListaDin<T>::distruggiAlbero(nodoAlbero<T, alberoListaDin<T>>* &radice) {
                                                                                  ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:68:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >* const&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(a.radice));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >* const' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
16:02:48 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:68:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >* const&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(a.radice));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >* const' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
16:04:23 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:23:40: error: invalid constructor; you probably meant 'alberoListaDin<T> (const alberoListaDin<T>&)'
  alberoListaDin(const alberoListaDin<T>); // costruttore di copia
                                        ^
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:64:1: error: prototype for 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&)' does not match any in class 'alberoListaDin<T>'
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: error: candidate is: alberoListaDin<T>::alberoListaDin()
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
16:04:36 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:68:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >* const&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(a.radice));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >* const' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
16:04:40 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:68:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodoAlbero<int, alberoListaDin<int> >* const&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(a.radice));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:64:1: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >* const' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:58:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin(){
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:58:1: note:   candidate expects 0 arguments, 1 provided
16:10:16 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\alberoListaDin.h:1:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:1:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:65:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodo<alberoListaDin<int> >&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(*a.radice->getFigli().primoLista()));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:57:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin() {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:57:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:131:19:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:139:24:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:48:55:   required from here
..\src\alberoListaDin.h:179:33: error: no match for 'operator==' (operand types are 'nodoAlbero<int, alberoListaDin<int> >' and 'nodoAlbero<int, alberoListaDin<int> >')
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note: candidate: template<class _StateT> bool std::operator==(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note: candidate: template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator==(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator==(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator==(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator==(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note: candidate: template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator==(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note: candidate: template<class _Tp> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator==(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note: candidate: template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value, bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const std::__cxx11::basic_string<_CharT>&)
     operator==(const basic_string<_CharT>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   mismatched types 'const _CharT*' and 'nodoAlbero<int, alberoListaDin<int> >'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_code&)
   operator==(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_condition&)
   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_code&)
   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_condition&)
   operator==(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:149:5:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:188:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:164:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:55: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodo<alberoListaDin<int> >&)'
             insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(*a.radice->getFigli().primoLista()));
                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:57:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin() {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:57:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:53:1:   required from here
..\src\alberoListaDin.h:168:46: error: conversion from 'alberoListaDin<int>*' to non-scalar type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}' requested
         posizione padre = p.radice->getPadre();
                                              ^
16:10:45 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\alberoListaDin.h:198:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:3:
..\src\alberoListaDin.h:1:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:198:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:1:0: error: unterminated #ifndef
 #ifndef _ALBEROLISTADIN_H
 
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:65:51: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodo<alberoListaDin<int> >&)'
         insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(*a.radice->getFigli().primoLista()));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:57:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin() {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:57:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::operator==(const alberoListaDin<T>&) const [with T = int]':
..\src\alberoListaDin.h:131:19:   required from 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\alberoListaDin.h:139:24:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:48:55:   required from here
..\src\alberoListaDin.h:179:33: error: no match for 'operator==' (operand types are 'nodoAlbero<int, alberoListaDin<int> >' and 'nodoAlbero<int, alberoListaDin<int> >')
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iosfwd:40:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note: candidate: template<class _StateT> bool std::operator==(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\postypes.h:216:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::fpos<_StateT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:64:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_pair.h:431:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::pair<_T1, _T2>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note: candidate: template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator==(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:292:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator==(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:349:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::reverse_iterator<_Iterator>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator==(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_algobase.h:67:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\char_traits.h:39,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator==(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::move_iterator<_IteratorL>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note: candidate: template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator==(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:146:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:41:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note: candidate: template<class _Tp> bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator==(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\allocator.h:152:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::allocator<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note: candidate: template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value, bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const std::__cxx11::basic_string<_CharT>&)
     operator==(const basic_string<_CharT>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5058:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const _CharT* __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5072:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   mismatched types 'const _CharT*' and 'nodoAlbero<int, alberoListaDin<int> >'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\string:52:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_classes.h:40,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:41,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_string.h:5084:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\ios_base.h:46:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:42,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_code&)
   operator==(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:284:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_condition&)
   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:289:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_code&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_code&)
   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:296:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_condition&'
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_condition&)
   operator==(const error_condition& __lhs,
   ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\system_error:303:3: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >' to 'const std::error_condition&'
In file included from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\locale_facets.h:48:0,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\basic_ios.h:37,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ios:44,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\ostream:38,
                 from c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:39,
                 from ..\src\testalberolistadin.cpp:1:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\bits\streambuf_iterator.h:204:5: note:   template argument deduction/substitution failed:
In file included from ..\src\testalberolistadin.cpp:3:0:
..\src\alberoListaDin.h:179:33: note:   'nodoAlbero<int, alberoListaDin<int> >' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
         return (*(this->radice) == *(a.radice));
                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:149:5:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:37:46:   required from here
..\src\alberoListaDin.h:188:9: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         this->cancSottoAlbero(this->radiceAlbero());
         ^~~~
..\src\alberoListaDin.h:164:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:191:55: error: no matching function for call to 'alberoListaDin<int>::alberoListaDin(nodo<alberoListaDin<int> >&)'
             insPrimoSottoAlbero(this->radiceAlbero(), alberoListaDin<T>(*a.radice->getFigli().primoLista()));
                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note: candidate: alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]
 alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>& a) {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:62:1: note:   no known conversion for argument 1 from 'nodo<alberoListaDin<int> >' to 'const alberoListaDin<int>&'
..\src\alberoListaDin.h:57:1: note: candidate: alberoListaDin<T>::alberoListaDin() [with T = int]
 alberoListaDin<T>::alberoListaDin() {
 ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:57:1: note:   candidate expects 0 arguments, 1 provided
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:53:1:   required from here
..\src\alberoListaDin.h:168:46: error: conversion from 'alberoListaDin<int>*' to non-scalar type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}' requested
         posizione padre = p.radice->getPadre();
                                              ^
16:27:02 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoListaDin.h:59:12: error: no matching function for call to 'alberoListaDin<int>::creaAlbero()'
  creaAlbero();
  ~~~~~~~~~~^~
..\src\alberoListaDin.h:82:6: note: candidate: void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]
 void alberoListaDin<T>::creaAlbero(typename alberoListaDin<T>::tipoelem e){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:82:6: note:   candidate expects 1 argument, 0 provided
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:29:39 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:82:6: error: prototype for 'void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem)' does not match any in class 'alberoListaDin<T>'
 void alberoListaDin<T>::creaAlbero(typename alberoListaDin<T>::tipoelem e){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:51:7: error: candidate is: void alberoListaDin<T>::creaAlbero()
  void creaAlbero();
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:30:06 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem)':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>(e);
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoListaDin.h:59:12: error: no matching function for call to 'alberoListaDin<int>::creaAlbero()'
  creaAlbero();
  ~~~~~~~~~~^~
..\src\alberoListaDin.h:82:6: note: candidate: void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]
 void alberoListaDin<T>::creaAlbero(typename alberoListaDin<T>::tipoelem e){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:82:6: note:   candidate expects 1 argument, 0 provided
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:30:14 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In constructor 'alberoListaDin<T>::alberoListaDin()':
..\src\alberoListaDin.h:59:14: error: expected primary-expression before ')' token
  creaAlbero(T);
              ^
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem)':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>(e);
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:30:29 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In constructor 'alberoListaDin<T>::alberoListaDin()':
..\src\alberoListaDin.h:59:21: error: expected primary-expression before ')' token
  creaAlbero(tipoelem);
                     ^
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero(alberoListaDin<T>::tipoelem)':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>(e);
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:31:18 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero()':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>();
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:31:23 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero()':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>;
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:27:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:31:52 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero()':
..\src\alberoListaDin.h:83:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>();
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:90:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:110:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:116:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:125:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:136:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:148:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:156:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:64: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                ^
..\src\testalberolistadin.cpp:16:87: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insPrimoSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                       ^
..\src\testalberolistadin.cpp:17:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                     ^
..\src\testalberolistadin.cpp:19:76: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                            ^
..\src\testalberolistadin.cpp:20:75: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                           ^
..\src\testalberolistadin.cpp:20:99: error: invalid cast to abstract class type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.primoFiglio(mioAlbero.radiceAlbero()), alberoListaDin<int>());
                                                                                                   ^
..\src\testalberolistadin.cpp:27:106: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                                                                                          ^
..\src\testalberolistadin.cpp:27:36: error: cannot declare variable 'posizioneCancellazione' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione posizioneCancellazione = mioAlbero.primoFiglio(mioAlbero.radiceAlbero());
                                    ^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:90:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero(){
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:29:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:29:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:93:26:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:64:   required from here
..\src\alberoListaDin.h:95:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (*temp);
                ^
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:28:53:   required from here
..\src\alberoListaDin.h:170:7: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if(p == p.radiceAlbero()){
        
..\src\alberoListaDin.h:174:95: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:5,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:89:25:   required from 'listaPuntatore<T>::~listaPuntatore() [with T = alberoListaDin<int>]'
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:42:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:24:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:105:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:116:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:117:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:118:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:127:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:136:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:137:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:138:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:139:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:142:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
16:32:17 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
16:35:23 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero()':
..\src\alberoListaDin.h:76:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>();
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
16:36:39 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::creaAlbero() [with T = int]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:76:15: error: cannot convert 'nodoAlbero<int, int>*' to 'nodoAlbero<int, alberoListaDin<int> >*' in assignment
  this->radice = new nodoAlbero<T, T>();
  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
16:38:46 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::creaAlbero()':
..\src\alberoListaDin.h:76:33: error: wrong number of template arguments (1, should be 2)
  this->radice = new nodoAlbero<T>();
                                 ^
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:9:7: note: provided for 'template<class T, class P> class nodoAlbero'
 class nodoAlbero{
       ^~~~~~~~~~
16:39:26 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
16:41:21 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
16:43:43 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:33:100: error: 'nodoAlbero<int, alberoListaDin<int> >* alberoListaDin<int>::radice' is private within this context
     cout << "Il primo figlio della radice è: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                                                    ^~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:52:36: note: declared private here
  nodoAlbero<T, alberoListaDin<T>>* radice;
                                    ^~~~~~
..\src\testalberolistadin.cpp:34:115: error: 'nodoAlbero<int, alberoListaDin<int> >* alberoListaDin<int>::radice' is private within this context
     cout << "L'ultimo fratello del primo sotto-albero è: " << mioAlbero.succFratello(sottoAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                                                                   ^~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:52:36: note: declared private here
  nodoAlbero<T, alberoListaDin<T>>* radice;
                                    ^~~~~~
16:44:33 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:34:118: error: base operand of '->' has non-pointer type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         cout << "Il primo figlio della radice è: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).radiceAlbero()->getElemento() << endl;
                                                                                                                      ^~
..\src\testalberolistadin.cpp:35:133: error: base operand of '->' has non-pointer type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         cout << "L'ultimo fratello del primo sotto-albero è: " << mioAlbero.succFratello(sottoAlbero.radiceAlbero()).radiceAlbero()->getElemento() << endl;
                                                                                                                                     ^~
16:45:26 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:34:104: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "Il primo figlio della radice è: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                        ^~~~~~~~~~~
..\src\testalberolistadin.cpp:35:119: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "L'ultimo fratello del primo sotto-albero è: " << mioAlbero.succFratello(sottoAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                                       ^~~~~~~~~~~
16:46:12 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:34:104: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "Il primo figlio della radice è: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                        ^~~~~~~~~~~
..\src\testalberolistadin.cpp:35:119: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "L'ultimo fratello del primo sotto-albero è: " << mioAlbero.succFratello(sottoAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                                       ^~~~~~~~~~~
16:48:16 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:3:5: error: 'alberoListaDin' was not declared in this scope
     alberoListaDin<int> mioAlbero;
     ^~~~~~~~~~~~~~
..\src\testalberolistadin.cpp:3:20: error: expected primary-expression before 'int'
     alberoListaDin<int> mioAlbero;
                    ^~~
..\src\testalberolistadin.cpp:4:5: error: 'cout' was not declared in this scope
     cout << "Albero vuoto:" << endl;
     ^~~~
..\src\testalberolistadin.cpp:4:32: error: 'endl' was not declared in this scope
     cout << "Albero vuoto:" << endl;
                                ^~~~
..\src\testalberolistadin.cpp:5:13: error: 'mioAlbero' was not declared in this scope
     cout << mioAlbero << endl;
             ^~~~~~~~~
..\src\testalberolistadin.cpp:13:20: error: expected primary-expression before 'int'
     alberoListaDin<int> sottoAlbero;
                    ^~~
..\src\testalberolistadin.cpp:14:5: error: 'sottoAlbero' was not declared in this scope
     sottoAlbero.creaAlbero();
     ^~~~~~~~~~~
..\src\testalberolistadin.cpp:22:20: error: expected primary-expression before 'int'
     alberoListaDin<int> altroSottoAlbero;
                    ^~~
..\src\testalberolistadin.cpp:23:5: error: 'altroSottoAlbero' was not declared in this scope
     altroSottoAlbero.creaAlbero();
     ^~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp:34:29: error: expected ')' before '&' token
     } catch (const exception& e) {
                             ^
..\src\testalberolistadin.cpp:34:29: error: expected '{' before '&' token
..\src\testalberolistadin.cpp:34:31: error: 'e' was not declared in this scope
     } catch (const exception& e) {
                               ^
..\src\testalberolistadin.cpp:39:20: error: expected primary-expression before 'int'
     alberoListaDin<int> mioAlberoCopia = mioAlbero;
                    ^~~
..\src\testalberolistadin.cpp:41:13: error: 'mioAlberoCopia' was not declared in this scope
     cout << mioAlberoCopia << endl;
             ^~~~~~~~~~~~~~
16:48:28 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:34:104: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "Il primo figlio della radice è: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                        ^~~~~~~~~~~
..\src\testalberolistadin.cpp:35:119: error: 'alberoListaDin<int>::posizione {aka class alberoListaDin<int>}' has no member named 'getElemento'
         cout << "L'ultimo fratello del primo sotto-albero è: " << mioAlbero.succFratello(sottoAlbero.radiceAlbero()).getElemento() << endl;
                                                                                                                       ^~~~~~~~~~~
16:50:21 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
Info: Nothing to build for 7 alb_nari
18:48:03 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
18:48:22 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
18:57:22 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:27:11: error: declaration of template parameter 'T' shadows template parameter
  template<class T>
           ^~~~~
..\src\alberoListaDin.h:16:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:66:6: error: prototype for 'void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&)' does not match any in class 'alberoListaDin<T>'
 void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T>>* origine, nodoAlbero<T, alberoListaDin<T>>* &destinazione) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:28:7: error: candidate is: template<class T> template<class T> void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&)
  void copiaAlbero(const nodoAlbero<T, alberoListaDin<T>>*, nodoAlbero<T, alberoListaDin<T>>* &);
       ^~~~~~~~~~~
18:58:01 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:27:11: error: declaration of template parameter 'T' shadows template parameter
  template<class T>
           ^~~~~
..\src\alberoListaDin.h:16:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:66:6: error: prototype for 'void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&)' does not match any in class 'alberoListaDin<T>'
 void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T>>* origine, nodoAlbero<T, alberoListaDin<T>>* &destinazione) {
      ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:28:7: error: candidate is: template<class T> template<class T> void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&)
  void copiaAlbero(const nodoAlbero<T, alberoListaDin<T>>*, nodoAlbero<T, alberoListaDin<T>>* &);
       ^~~~~~~~~~~
18:58:38 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In member function 'void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&)':
..\src\alberoListaDin.h:67:35: error: 'originie' was not declared in this scope
         destinazione->setElemento(originie->getElemento());
                                   ^~~~~~~~
18:58:44 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
19:01:27 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:17:11: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
    ~~~~~~~^~~~~~~~
..\src\nodoAlbero.h:17:39: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
                                ~~~~~~~^~~~~~~~
19:02:25 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:17:11: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
    ~~~~~~~^~~~~~~~
..\src\nodoAlbero.h:17:39: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
                                ~~~~~~~^~~~~~~~
19:03:58 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'void nodoAlbero<T, P>::setPadre(P*) [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:107:3:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:10:26:   required from here
..\src\nodoAlbero.h:24:31: error: cannot convert 'alberoListaDin<int>*' to 'nodoAlbero<int, alberoListaDin<int> >*' in assignment
  void setPadre (P* p) { padre = p; };
                         ~~~~~~^~~
..\src\nodoAlbero.h: In instantiation of 'P* nodoAlbero<T, P>::getPadre() const [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:122:37:   required from 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:14:68:   required from here
..\src\nodoAlbero.h:25:32: error: cannot convert 'nodoAlbero<int, alberoListaDin<int> >* const' to 'alberoListaDin<int>*' in return
  P* getPadre () const { return padre; };
                                ^~~~~
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:17:4: error: no matching function for call to 'listaPuntatore<alberoListaDin<int> >::cercaElemento(nodoAlbero<int, alberoListaDin<int> >*)'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
    ^~~~~
In file included from ..\src\nodoAlbero.h:5:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:214:39: note: candidate: listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const [with T = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*; listaPuntatore<T>::tipoelem = alberoListaDin<int>]
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'listaPuntatore<alberoListaDin<int> >::tipoelem {aka alberoListaDin<int>}'
19:04:14 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:17:11: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
    ~~~~~~~^~~~~~~~
..\src\nodoAlbero.h:17:39: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
                                ~~~~~~~^~~~~~~~
19:05:17 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:16:11: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
    ~~~~~~~^~~~~~~~
..\src\nodoAlbero.h:16:39: error: 'class alberoListaDin<int>' has no member named 'getFigli'
    padre->getFigli().cancLista(padre->getFigli().cercaElemento(this));
                                ~~~~~~~^~~~~~~~
19:06:15 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h: In instantiation of 'nodoAlbero<T, P>::~nodoAlbero() [with T = int; P = alberoListaDin<int>]':
..\src\alberoListaDin.h:228:9:   required from 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]'
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:179:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:15:64:   required from here
..\src\nodoAlbero.h:16:11: error: 'nodoAlbero<int, alberoListaDin<int> >* alberoListaDin<int>::radice' is private within this context
    padre->radice->getFigli().cancLista(padre->radice->getFigli().cercaElemento(this));
    ~~~~~~~^~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:53:36: note: declared private here
  nodoAlbero<T, alberoListaDin<T>>* radice;
                                    ^~~~~~
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:16:47: error: 'nodoAlbero<int, alberoListaDin<int> >* alberoListaDin<int>::radice' is private within this context
    padre->radice->getFigli().cancLista(padre->radice->getFigli().cercaElemento(this));
                                        ~~~~~~~^~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:53:36: note: declared private here
  nodoAlbero<T, alberoListaDin<T>>* radice;
                                    ^~~~~~
In file included from ..\src\alberoListaDin.h:8:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodoAlbero.h:16:4: error: no matching function for call to 'listaPuntatore<alberoListaDin<int> >::cercaElemento(nodoAlbero<int, alberoListaDin<int> >*)'
    padre->radice->getFigli().cancLista(padre->radice->getFigli().cercaElemento(this));
    ^~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:214:39: note: candidate: listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(listaPuntatore<T>::tipoelem) const [with T = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*; listaPuntatore<T>::tipoelem = alberoListaDin<int>]
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: note:   no known conversion for argument 1 from 'nodoAlbero<int, alberoListaDin<int> >*' to 'listaPuntatore<alberoListaDin<int> >::tipoelem {aka alberoListaDin<int>}'
19:09:38 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
19:10:26 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
19:12:07 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
g++ -o "7 alb_nari.exe" "src\\testalberolistadin.o" 
Info: Nothing to build for 7 alb_nari
19:13:36 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\nodo.h:11:37:   required from 'nodo<T>::nodo(nodo<T>::tipoelem) [with T = alberoListaDin<int>; nodo<T>::tipoelem = alberoListaDin<int>]'
..\src\listaPuntatore.h:170:24:   required from 'void listaPuntatore<T>::insLista(listaPuntatore<T>::tipoelem, listaPuntatore<T>::posizione) [with T = alberoListaDin<int>; listaPuntatore<T>::tipoelem = alberoListaDin<int>; listaPuntatore<T>::posizione = nodo<alberoListaDin<int> >*]'
..\src\alberoListaDin.h:180:2:   required from 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, alberoListaDin<T>) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
..\src\testalberolistadin.cpp:12:86:   required from here
..\src\alberoListaDin.h:247:24: error: invalid initialization of non-const reference of type 'alberoListaDin<int>::posizione& {aka alberoListaDin<int>&}' from an rvalue of type 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
         cancSottoAlbero(this->radiceAlbero());
         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:200:6: note:   initializing argument 1 of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione&) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione& p){
      ^~~~~~~~~~~~~~~~~
19:14:53 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:4:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:17:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>>{
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:7:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:120:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:134:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:134:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:140:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:146:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:146:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:155:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const{
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:166:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:166:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:187:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a){
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:187:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:200:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:4:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:10:25: error: cannot declare variable 'sottoAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero;
                         ^~~~~~~~~~~
..\src\testalberolistadin.cpp:12:62: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero.insPrimoSottoAlbero(sottoAlbero.radiceAlbero(), alberoListaDin<int>());
                                                              ^
..\src\testalberolistadin.cpp:12:85: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero.insPrimoSottoAlbero(sottoAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                                     ^
..\src\testalberolistadin.cpp:13:62: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero.insPrimoSottoAlbero(sottoAlbero.radiceAlbero(), alberoListaDin<int>());
                                                              ^
..\src\testalberolistadin.cpp:13:85: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero.insPrimoSottoAlbero(sottoAlbero.radiceAlbero(), alberoListaDin<int>());
                                                                                     ^
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero);
                                                    ^
..\src\testalberolistadin.cpp:22:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> copiaAlbero = albero;
                                       ^~~~~~
..\src\testalberolistadin.cpp:22:25: error: cannot declare variable 'copiaAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> copiaAlbero = albero;
                         ^~~~~~~~~~~
..\src\testalberolistadin.cpp:28:111: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione secondoFiglio = albero.succFratello(albero.primoFiglio(albero.radiceAlbero()));
                                                                                                               ^
..\src\testalberolistadin.cpp:28:36: error: cannot declare variable 'secondoFiglio' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int>::posizione secondoFiglio = albero.succFratello(albero.primoFiglio(albero.radiceAlbero()));
                                    ^~~~~~~~~~~~~
..\src\testalberolistadin.cpp:29:41: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.cancSottoAlbero(secondoFiglio);
                                         ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:107:18:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:7:23:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:107:18:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:7:23:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:12:62:   required from here
..\src\alberoListaDin.h:120:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:125:22: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         return (*temp);
                      ^
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:54:20:   required from 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)'
..\src\alberoListaDin.h:46:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:19:38:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:8,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:46:7:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:19:38:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::copiaAlbero(const nodoAlbero<T, alberoListaDin<T> >*, nodoAlbero<T, alberoListaDin<T> >*&) [with T = int]':
..\src\alberoListaDin.h:84:16:   required from 'alberoListaDin<T>::alberoListaDin(const alberoListaDin<T>&) [with T = int]'
..\src\testalberolistadin.cpp:29:41:   required from here
..\src\alberoListaDin.h:73:44: error: invalid new-expression of abstract class type 'alberoListaDin<int>'
             alberoListaDin<T>* childCopy = new alberoListaDin<T>();
                                            ^~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:74:31: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
             copiaAlbero(iter->getElemento().radice, childCopy->radice);
                         ~~~~~~^~~~~~~~~~~
..\src\alberoListaDin.h:75:38: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'insLista'; did you mean 'fineLista'?
             destinazione->getFigli().insLista(*childCopy, destinazione->getFigli().ultimoLista());
                                       
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:134:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:135:31: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  return (*p.radice->getPadre());
                               ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:146:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:147:13: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!foglia(p))
       ~~~~~~^~~
..\src\alberoListaDin.h:148:46: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getFigli().primoLista()->getElemento());
                                               
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:157:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                         
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:35:1:   required from here
..\src\alberoListaDin.h:166:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const{
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:167:21: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
  if (!ultimoFratello(p)){
       ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:169:94: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
   typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                               
..\src\alberoListaDin.h:170:66: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
   return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                   
..\src\alberoListaDin.h:173:12: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
   return (p);
            ^
19:19:42 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberolistadin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberolistadin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberolistadin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberolistadin.h:114:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:142:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:142:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberolistadin.h:147:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:152:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:152:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberolistadin.h:160:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:169:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:169:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberolistadin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a) {
      ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberolistadin.h:185:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a) {
      ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:185:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberolistadin.h:195:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:13:59: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                           ^
..\src\testalberolistadin.cpp:13:82: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                  ^
..\src\testalberolistadin.cpp:15:25: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero2;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:18:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:19:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero2);
                                                     ^
..\src\testalberolistadin.cpp:26:78: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Padre della radice: " << mioAlbero.padre(mioAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                              ^
..\src\testalberolistadin.cpp:27:91: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Primo figlio della radice: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                                           ^
..\src\testalberolistadin.cpp:28:97: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Ultimo fratello della radice: " << mioAlbero.ultimoFratello(mioAlbero.radiceAlbero()) << endl;
                                                                                                 ^
..\src\testalberolistadin.cpp:31:25: error: cannot declare variable 'altroAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> altroAlbero;
                         ^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>::~alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberolistadin.h:88:20: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cancSottoAlbero(this->radiceAlbero());
     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberolistadin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberolistadin.h:104:24:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:8:26:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberolistadin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberolistadin.h:104:24:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:8:26:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:13:59:   required from here
..\src\alberolistadin.h:114:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:119:22: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         return (*temp);
                      ^
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:32:19:   required from here
..\src\alberolistadin.h:219:24: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         cancSottoAlbero(this->radiceAlbero());
         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
..\src\alberolistadin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\alberolistadin.h:88:20:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberolistadin.h:196:11: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p == p.radiceAlbero()) {
            
..\src\alberolistadin.h:199:101: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
         p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                      
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberolistadin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:54:20:   required from 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)'
..\src\alberolistadin.h:47:16:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:23:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberolistadin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberolistadin.h:47:16:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:23:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:39:1:   required from here
..\src\alberolistadin.h:142:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:143:34: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     return (*p.radice->getPadre());
                                  ^
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:39:1:   required from here
..\src\alberolistadin.h:152:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:153:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (!foglia(p))
          ~~~~~~^~~
..\src\alberolistadin.h:154:52: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p.radice->getFigli().primoLista()->getElemento());
                                                     
..\src\alberolistadin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:39:1:   required from here
..\src\alberolistadin.h:162:78: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                               
..\src\alberolistadin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:39:1:   required from here
..\src\alberolistadin.h:169:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberolistadin.h:170:24: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (!ultimoFratello(p)) {
          ~~~~~~~~~~~~~~^~~
..\src\alberolistadin.h:171:100: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
         typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                                     
..\src\alberolistadin.h:172:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                         
..\src\alberolistadin.h:174:18: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         return (p);
                  ^
19:20:10 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:2:
..\src\alberoAstratto.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:2:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:2:
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:2:0:
..\src\alberoListaDin.h:114:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:142:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:142:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:147:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(typename alberoListaDin<T>::posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:160:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(typename alberoListaDin<T>::posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:169:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:169:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:179:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:185:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(typename alberoListaDin<T>::posizione p, alberoListaDin<T> a) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:185:6: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:195:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(typename alberoListaDin<T>::posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:8:25: error: cannot declare variable 'mioAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> mioAlbero;
                         ^~~~~~~~~
..\src\testalberolistadin.cpp:14:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:59: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     sottoAlbero1.insSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                           ^
..\src\testalberolistadin.cpp:16:82: error: invalid cast to abstract class type 'alberoListaDin<int>'
     sottoAlbero1.insSottoAlbero(sottoAlbero1.radiceAlbero(), alberoListaDin<int>());
                                                                                  ^
..\src\testalberolistadin.cpp:18:25: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero2;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:21:58: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insPrimoSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero1);
                                                          ^
..\src\testalberolistadin.cpp:22:53: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     mioAlbero.insSottoAlbero(mioAlbero.radiceAlbero(), sottoAlbero2);
                                                     ^
..\src\testalberolistadin.cpp:29:78: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Padre della radice: " << mioAlbero.padre(mioAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                              ^
..\src\testalberolistadin.cpp:30:91: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Primo figlio della radice: " << mioAlbero.primoFiglio(mioAlbero.radiceAlbero()).radice->getElemento() << endl;
                                                                                           ^
..\src\testalberolistadin.cpp:31:97: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cout << "Ultimo fratello della radice: " << mioAlbero.ultimoFratello(mioAlbero.radiceAlbero()) << endl;
                                                                                                 ^
..\src\testalberolistadin.cpp:34:25: error: cannot declare variable 'altroAlbero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> altroAlbero;
                         ^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:2:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::~alberoListaDin() [with T = int]':
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoListaDin.h:88:20: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     cancSottoAlbero(this->radiceAlbero());
     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:2:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:104:24:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:11:26:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:2:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:104:24:   required from 'void alberoListaDin<T>::insRadice(alberoListaDin<T>::tipoelem) [with T = int; alberoListaDin<T>::tipoelem = int]'
..\src\testalberolistadin.cpp:11:26:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:2:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:59:   required from here
..\src\alberoListaDin.h:114:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:119:22: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         return (*temp);
                      ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>& alberoListaDin<T>::operator=(const alberoListaDin<T>&) [with T = int]':
..\src\testalberolistadin.cpp:35:19:   required from here
..\src\alberoListaDin.h:219:24: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         cancSottoAlbero(this->radiceAlbero());
         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\alberoListaDin.h:88:20:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:8:25:   required from here
..\src\alberoListaDin.h:196:11: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p == p.radiceAlbero()) {
            
..\src\alberoListaDin.h:199:101: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
         p.radice->getPadre()->radice->getFigli().cancLista(p.radice->getPadre()->radice->getFigli().cercaElemento(p));
                                                                                                      
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:2:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\listaPuntatore.h:54:20:   required from 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)'
..\src\alberoListaDin.h:47:16:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:26:13:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:2:
..\src\listaPuntatore.h: In instantiation of 'std::ostream& operator<<(std::ostream&, const listaPuntatore<alberoListaDin<int> >&)':
..\src\alberoListaDin.h:47:16:   required from 'std::ostream& operator<<(std::ostream&, const alberoListaDin<int>&)'
..\src\testalberolistadin.cpp:26:13:   required from here
..\src\listaPuntatore.h:57:24: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
     os << "<" << temp->getElemento() << ">" << endl;
                  ~~~~~~^~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:2:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:42:1:   required from here
..\src\alberoListaDin.h:142:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:34: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     return (*p.radice->getPadre());
                                  ^
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:42:1:   required from here
..\src\alberoListaDin.h:152:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:153:16: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (!foglia(p))
          ~~~~~~^~~
..\src\alberoListaDin.h:154:52: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p.radice->getFigli().primoLista()->getElemento());
                                                     
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:42:1:   required from here
..\src\alberoListaDin.h:162:78: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p == p.radice->getPadre()->radice->getFigli().ultimoLista()->getElemento());
                                                                               
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:42:1:   required from here
..\src\alberoListaDin.h:169:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(typename alberoListaDin<T>::posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:170:24: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (!ultimoFratello(p)) {
          ~~~~~~~~~~~~~~^~~
..\src\alberoListaDin.h:171:100: error: 'class listaPuntatore<alberoListaDin<int> >' has no member named 'cercaElemento'
         typename listaPuntatore<posizione>::posizione n = p.radice->getPadre()->radice->getFigli().cercaElemento(p);
                                                                                                     
..\src\alberoListaDin.h:172:72: error: 'class nodo<alberoListaDin<int> >' has no member named 'getElemento'; did you mean 'elemento'?
         return (p.radice->getPadre()->radice->getFigli().succLista(n)->getElemento());
                                                                         
..\src\alberoListaDin.h:174:18: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
         return (p);
                  ^
19:23:55 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:16:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:65:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:4:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:8:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:4:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:65:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:78:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:83:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:83:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:91:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:99:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:99:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:114:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:126:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:19:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:19:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:65:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:66:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:151:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:18:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:18:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:151:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:147:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:147:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:72:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:74:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:79:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:79:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:83:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:84:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:85:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:87:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:93:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:99:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:101:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:101:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:101:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:103:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
19:24:17 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:144:2: error: stray '#' in program
 }#ifndef _ALBEROLISTADIN_H
  ^
..\src\alberoListaDin.h:318:2: error: #endif without #if
 #endif // _ALBEROLISTADIN_H
  ^~~~~
..\src\alberoListaDin.h:144:3: error: 'ifndef' does not name a type
 }#ifndef _ALBEROLISTADIN_H
   ^~~~~~
..\src\alberoListaDin.h:208:39: error: redefinition of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:65:39: note: 'virtual alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const' previously declared here
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:213:39: error: redefinition of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:39: note: 'virtual alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const' previously declared here
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:221:6: error: redefinition of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:78:6: note: 'virtual bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const' previously declared here
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:226:39: error: redefinition of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:83:39: note: 'virtual alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const' previously declared here
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:234:6: error: redefinition of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:91:6: note: 'virtual bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const' previously declared here
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:242:39: error: redefinition of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:99:39: note: 'virtual alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const' previously declared here
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:250:6: error: redefinition of 'void alberoListaDin<T>::insRadice(const T&)'
 void alberoListaDin<T>::insRadice(const T& elem) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:107:6: note: 'void alberoListaDin<T>::insRadice(const T&)' previously declared here
 void alberoListaDin<T>::insRadice(const T& elem) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:257:6: error: redefinition of 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, const alberoListaDin<T>&)'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:114:6: note: 'void alberoListaDin<T>::insPrimoSottoAlbero(alberoListaDin<T>::posizione, const alberoListaDin<T>&)' previously declared here
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:269:6: error: redefinition of 'void alberoListaDin<T>::insSottoAlbero(alberoListaDin<T>::posizione, const alberoListaDin<T>&)'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:126:6: note: 'void alberoListaDin<T>::insSottoAlbero(alberoListaDin<T>::posizione, const alberoListaDin<T>&)' previously declared here
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:281:6: error: redefinition of 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione)'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: note: 'void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione)' previously declared here
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:306:6: error: redefinition of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*)'
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:290:6: note: 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*)' previously declared here
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:16:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:65:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:4:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:8:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:4:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:65:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:70:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:78:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:83:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:83:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:91:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:99:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:99:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:114:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:126:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:19:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:19:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:65:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:66:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:294:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:18:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:18:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:294:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:138:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:290:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:290:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:72:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:74:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:79:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:5,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:79:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:83:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:84:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:85:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:87:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:93:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:99:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:101:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:101:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:101:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:103:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
19:26:01 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:6: note: declared private here
  int lunghezza;
      ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:29:36 **** Rebuild of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o tempalbpt.exe "src\\testTree.o" 
Info: Nothing to build for tempalbpt
23:31:01 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o tempalbpt.exe "src\\testTree.o" 
Info: Nothing to build for tempalbpt
Info: Nothing to build for 1 liste
23:39:39 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:3:22: fatal error: nodoalbero: No such file or directory
 #include "nodoalbero"
                      ^
compilation terminated.
Info: Nothing to build for 1 liste
23:42:35 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:3:22: fatal error: nodoalbero: No such file or directory
 #include "nodoalbero"
                      ^
compilation terminated.
Info: Nothing to build for 1 liste
23:42:48 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:11:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:11:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                               ^
..\src\alberopt.h:11:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:12:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::Nodo Nodo;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:12:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::Nodo Nodo;
                                               ^
..\src\alberopt.h:12:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::Nodo Nodo;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:19:26: error: 'TipoElemento' has not been declared
     void inserisciRadice(TipoElemento);
                          ^~~~~~~~~~~~
..\src\alberopt.h:20:5: error: 'Nodo' does not name a type
     Nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:20:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:21:5: error: 'Nodo' does not name a type
     Nodo genitore(Nodo) const;
     ^~~~
..\src\alberopt.h:21:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:22:17: error: 'Nodo' has not been declared
     bool foglia(Nodo) const;
                 ^~~~
..\src\alberopt.h:23:5: error: 'Nodo' does not name a type
     Nodo primoFiglio(Nodo) const;
     ^~~~
..\src\alberopt.h:23:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:24:25: error: 'Nodo' has not been declared
     bool ultimoFratello(Nodo) const;
                         ^~~~
..\src\alberopt.h:25:5: error: 'Nodo' does not name a type
     Nodo fratelloSuccessivo(Nodo) const;
     ^~~~
..\src\alberopt.h:25:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:26:36: error: 'Nodo' has not been declared
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                    ^~~~
..\src\alberopt.h:26:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:26:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:26:78: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                              ^
..\src\alberopt.h:26:78: error: template argument 2 is invalid
..\src\alberopt.h:26:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:26:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:26:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:26:79: error: template argument 2 is invalid
..\src\alberopt.h:26:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:26:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:26:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:26:79: error: template argument 2 is invalid
..\src\alberopt.h:26:42: error: 'Albero' is not a type
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                          ^~~~~~
..\src\alberopt.h:26:48: error: expected ',' or '...' before '<' token
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                ^
..\src\alberopt.h:27:31: error: 'Nodo' has not been declared
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                               ^~~~
..\src\alberopt.h:27:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:27:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:27:73: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                         ^
..\src\alberopt.h:27:73: error: template argument 2 is invalid
..\src\alberopt.h:27:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:27:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:27:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:27:74: error: template argument 2 is invalid
..\src\alberopt.h:27:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:27:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:27:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:27:74: error: template argument 2 is invalid
..\src\alberopt.h:27:37: error: 'Albero' is not a type
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                     ^~~~~~
..\src\alberopt.h:27:43: error: expected ',' or '...' before '<' token
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                           ^
..\src\alberopt.h:28:30: error: 'Nodo' has not been declared
     void cancellaSottoalbero(Nodo);
                              ^~~~
..\src\alberopt.h:29:21: error: 'Nodo' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                     ^~~~
..\src\alberopt.h:29:27: error: 'TipoElemento' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                           ^~~~~~~~~~~~
..\src\alberopt.h:30:5: error: 'TipoElemento' does not name a type
     TipoElemento leggiNodo(Nodo) const;
     ^~~~~~~~~~~~
..\src\alberopt.h:30:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::TipoElemento' was intended)
..\src\alberopt.h:32:31: error: 'Nodo' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                               ^~~~
..\src\alberopt.h:32:37: error: 'TipoElemento' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                                     ^~~~~~~~~~~~
..\src\alberopt.h:33:28: error: 'Nodo' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                            ^~~~
..\src\alberopt.h:33:34: error: 'TipoElemento' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                                  ^~~~~~~~~~~~
..\src\alberopt.h:37:5: error: 'Nodo' does not name a type
     Nodo radice;
     ^~~~
..\src\alberopt.h:37:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:39:16: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                ^~~~
..\src\alberopt.h:39:22: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                      ^~~~
..\src\alberopt.h:40:17: error: 'Nodo' has not been declared
     void stampa(Nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'AlberoPt<T>::~AlberoPt()':
..\src\alberopt.h:46:29: error: 'radice' was not declared in this scope
         cancellaSottoalbero(radice);
                             ^~~~~~
..\src\alberopt.h: In constructor 'AlberoPt<T>::AlberoPt()':
..\src\alberopt.h:52:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: In copy constructor 'AlberoPt<T>::AlberoPt(const AlberoPt<T>&)':
..\src\alberopt.h:58:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:66:25: error: variable or field 'copia' declared void
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:66:25: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:66:33: error: 'Nodo' was not declared in this scope
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h: In member function 'bool AlberoPt<T>::vuoto() const':
..\src\alberopt.h:80:12: error: 'radice' was not declared in this scope
     return radice.listaVuota();
            ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:84:35: error: variable or field 'inserisciRadice' declared void
 void AlberoPt<T>::inserisciRadice(TipoElemento e) {
                                   ^~~~~~~~~~~~
..\src\alberopt.h:84:35: error: 'TipoElemento' was not declared in this scope
..\src\alberopt.h:92:55: error: no 'typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const' member function declared in class 'AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:100:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                        ^~~~
..\src\alberopt.h:100:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:100:48: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                                ^~~~~~~~~~~~
..\src\alberopt.h:107:37: error: variable or field 'inserisciFratello' declared void
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                     ^~~~
..\src\alberopt.h:107:37: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:107:45: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                             ^~~~~~~~~~~~
..\src\alberopt.h:117:30: error: variable or field 'scriviNodo' declared void
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                              ^~~~
..\src\alberopt.h:117:30: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:117:38: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                                      ^~~~~~~~~~~~
..\src\alberopt.h:124:59: error: 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(Nodo n) const {
                                                           ^~~~
..\src\alberopt.h:124:59: error: template definition of non-template 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo'
..\src\alberopt.h:124:59: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:133:50: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::genitore(Nodo n) const {
                                                  ^~~~
..\src\alberopt.h:133:50: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore'
..\src\alberopt.h:133:50: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:144:26: error: 'bool AlberoPt<T>::foglia' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::foglia(Nodo n) const {
                          ^~~~
..\src\alberopt.h:144:26: error: template definition of non-template 'bool AlberoPt<T>::foglia'
..\src\alberopt.h:144:26: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:152:53: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(Nodo n) const {
                                                     ^~~~
..\src\alberopt.h:152:53: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio'
..\src\alberopt.h:152:53: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:163:34: error: 'bool AlberoPt<T>::ultimoFratello' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::ultimoFratello(Nodo n) const {
                                  ^~~~
..\src\alberopt.h:163:34: error: template definition of non-template 'bool AlberoPt<T>::ultimoFratello'
..\src\alberopt.h:163:34: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:171:60: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo(Nodo n) const {
                                                            ^~~~
..\src\alberopt.h:171:60: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:171:60: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:182:45: error: variable or field 'inserisciPrimoSottoalbero' declared void
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                             ^~~~
..\src\alberopt.h:182:45: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:182:60: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                            ^~~~~~~~~~~~
..\src\alberopt.h:182:74: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:182:89: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:182:89: error: template argument 2 is invalid
..\src\alberopt.h:182:94: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                              ^
..\src\alberopt.h:195:40: error: variable or field 'inserisciSottoalbero' declared void
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                        ^~~~
..\src\alberopt.h:195:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:195:55: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                       ^~~~~~~~~~~~
..\src\alberopt.h:195:69: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                     ^~~~~~~~~~~~~~
..\src\alberopt.h:195:84: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                    ^
..\src\alberopt.h:195:84: error: template argument 2 is invalid
..\src\alberopt.h:195:89: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:211:39: error: variable or field 'cancellaSottoalbero' declared void
 void AlberoPt<T>::cancellaSottoalbero(Nodo n) {
                                       ^~~~
..\src\alberopt.h:211:39: error: 'Nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void AlberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:229:16: error: 'radice' was not declared in this scope
         stampa(radice);
                ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:236:26: error: variable or field 'stampa' declared void
 void AlberoPt<T>::stampa(Nodo n) const {
                          ^~~~
..\src\alberopt.h:236:26: error: 'Nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
Info: Nothing to build for 1 liste
23:43:11 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:10:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:10:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                               ^
..\src\alberopt.h:10:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:11:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:11:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                               ^
..\src\alberopt.h:11:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:18:26: error: 'TipoElemento' has not been declared
     void inserisciRadice(TipoElemento);
                          ^~~~~~~~~~~~
..\src\alberopt.h:19:5: error: 'Nodo' does not name a type
     Nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:19:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:20:5: error: 'Nodo' does not name a type
     Nodo genitore(Nodo) const;
     ^~~~
..\src\alberopt.h:20:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:21:17: error: 'Nodo' has not been declared
     bool foglia(Nodo) const;
                 ^~~~
..\src\alberopt.h:22:5: error: 'Nodo' does not name a type
     Nodo primoFiglio(Nodo) const;
     ^~~~
..\src\alberopt.h:22:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:23:25: error: 'Nodo' has not been declared
     bool ultimoFratello(Nodo) const;
                         ^~~~
..\src\alberopt.h:24:5: error: 'Nodo' does not name a type
     Nodo fratelloSuccessivo(Nodo) const;
     ^~~~
..\src\alberopt.h:24:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:25:36: error: 'Nodo' has not been declared
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                    ^~~~
..\src\alberopt.h:25:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:25:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:25:78: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                              ^
..\src\alberopt.h:25:78: error: template argument 2 is invalid
..\src\alberopt.h:25:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:25:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:25:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:25:79: error: template argument 2 is invalid
..\src\alberopt.h:25:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:25:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:25:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:25:79: error: template argument 2 is invalid
..\src\alberopt.h:25:42: error: 'Albero' is not a type
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                          ^~~~~~
..\src\alberopt.h:25:48: error: expected ',' or '...' before '<' token
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                ^
..\src\alberopt.h:26:31: error: 'Nodo' has not been declared
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                               ^~~~
..\src\alberopt.h:26:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:26:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:26:73: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                         ^
..\src\alberopt.h:26:73: error: template argument 2 is invalid
..\src\alberopt.h:26:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:26:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:26:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:26:74: error: template argument 2 is invalid
..\src\alberopt.h:26:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:26:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:26:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:26:74: error: template argument 2 is invalid
..\src\alberopt.h:26:37: error: 'Albero' is not a type
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                     ^~~~~~
..\src\alberopt.h:26:43: error: expected ',' or '...' before '<' token
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                           ^
..\src\alberopt.h:27:30: error: 'Nodo' has not been declared
     void cancellaSottoalbero(Nodo);
                              ^~~~
..\src\alberopt.h:28:21: error: 'Nodo' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                     ^~~~
..\src\alberopt.h:28:27: error: 'TipoElemento' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                           ^~~~~~~~~~~~
..\src\alberopt.h:29:5: error: 'TipoElemento' does not name a type
     TipoElemento leggiNodo(Nodo) const;
     ^~~~~~~~~~~~
..\src\alberopt.h:29:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::TipoElemento' was intended)
..\src\alberopt.h:31:31: error: 'Nodo' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                               ^~~~
..\src\alberopt.h:31:37: error: 'TipoElemento' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                                     ^~~~~~~~~~~~
..\src\alberopt.h:32:28: error: 'Nodo' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                            ^~~~
..\src\alberopt.h:32:34: error: 'TipoElemento' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                                  ^~~~~~~~~~~~
..\src\alberopt.h:36:5: error: 'Nodo' does not name a type
     Nodo radice;
     ^~~~
..\src\alberopt.h:36:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:38:16: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                ^~~~
..\src\alberopt.h:38:22: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                      ^~~~
..\src\alberopt.h:39:17: error: 'Nodo' has not been declared
     void stampa(Nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'AlberoPt<T>::~AlberoPt()':
..\src\alberopt.h:45:29: error: 'radice' was not declared in this scope
         cancellaSottoalbero(radice);
                             ^~~~~~
..\src\alberopt.h: In constructor 'AlberoPt<T>::AlberoPt()':
..\src\alberopt.h:51:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: In copy constructor 'AlberoPt<T>::AlberoPt(const AlberoPt<T>&)':
..\src\alberopt.h:57:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:65:25: error: variable or field 'copia' declared void
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:65:25: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:65:33: error: 'Nodo' was not declared in this scope
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h: In member function 'bool AlberoPt<T>::vuoto() const':
..\src\alberopt.h:79:12: error: 'radice' was not declared in this scope
     return radice.listaVuota();
            ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:83:35: error: variable or field 'inserisciRadice' declared void
 void AlberoPt<T>::inserisciRadice(TipoElemento e) {
                                   ^~~~~~~~~~~~
..\src\alberopt.h:83:35: error: 'TipoElemento' was not declared in this scope
..\src\alberopt.h:91:55: error: no 'typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const' member function declared in class 'AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:99:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                        ^~~~
..\src\alberopt.h:99:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:99:48: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                                ^~~~~~~~~~~~
..\src\alberopt.h:106:37: error: variable or field 'inserisciFratello' declared void
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                     ^~~~
..\src\alberopt.h:106:37: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:106:45: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                             ^~~~~~~~~~~~
..\src\alberopt.h:116:30: error: variable or field 'scriviNodo' declared void
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                              ^~~~
..\src\alberopt.h:116:30: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:116:38: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                                      ^~~~~~~~~~~~
..\src\alberopt.h:123:59: error: 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(Nodo n) const {
                                                           ^~~~
..\src\alberopt.h:123:59: error: template definition of non-template 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo'
..\src\alberopt.h:123:59: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:132:50: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::genitore(Nodo n) const {
                                                  ^~~~
..\src\alberopt.h:132:50: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore'
..\src\alberopt.h:132:50: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:143:26: error: 'bool AlberoPt<T>::foglia' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::foglia(Nodo n) const {
                          ^~~~
..\src\alberopt.h:143:26: error: template definition of non-template 'bool AlberoPt<T>::foglia'
..\src\alberopt.h:143:26: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:151:53: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(Nodo n) const {
                                                     ^~~~
..\src\alberopt.h:151:53: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio'
..\src\alberopt.h:151:53: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:162:34: error: 'bool AlberoPt<T>::ultimoFratello' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::ultimoFratello(Nodo n) const {
                                  ^~~~
..\src\alberopt.h:162:34: error: template definition of non-template 'bool AlberoPt<T>::ultimoFratello'
..\src\alberopt.h:162:34: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:170:60: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo(Nodo n) const {
                                                            ^~~~
..\src\alberopt.h:170:60: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:170:60: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:181:45: error: variable or field 'inserisciPrimoSottoalbero' declared void
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                             ^~~~
..\src\alberopt.h:181:45: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:181:60: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                            ^~~~~~~~~~~~
..\src\alberopt.h:181:74: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:181:89: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:181:89: error: template argument 2 is invalid
..\src\alberopt.h:181:94: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                              ^
..\src\alberopt.h:194:40: error: variable or field 'inserisciSottoalbero' declared void
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                        ^~~~
..\src\alberopt.h:194:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:194:55: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                       ^~~~~~~~~~~~
..\src\alberopt.h:194:69: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                     ^~~~~~~~~~~~~~
..\src\alberopt.h:194:84: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                    ^
..\src\alberopt.h:194:84: error: template argument 2 is invalid
..\src\alberopt.h:194:89: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:210:39: error: variable or field 'cancellaSottoalbero' declared void
 void AlberoPt<T>::cancellaSottoalbero(Nodo n) {
                                       ^~~~
..\src\alberopt.h:210:39: error: 'Nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void AlberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:228:16: error: 'radice' was not declared in this scope
         stampa(radice);
                ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:235:26: error: variable or field 'stampa' declared void
 void AlberoPt<T>::stampa(Nodo n) const {
                          ^~~~
..\src\alberopt.h:235:26: error: 'Nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
Info: Nothing to build for 1 liste
23:45:15 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:12:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:12:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                               ^
..\src\alberopt.h:12:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:13:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:13:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                               ^
..\src\alberopt.h:13:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:20:26: error: 'TipoElemento' has not been declared
     void inserisciRadice(TipoElemento);
                          ^~~~~~~~~~~~
..\src\alberopt.h:21:5: error: 'Nodo' does not name a type
     Nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:21:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:22:5: error: 'Nodo' does not name a type
     Nodo genitore(Nodo) const;
     ^~~~
..\src\alberopt.h:22:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:23:17: error: 'Nodo' has not been declared
     bool foglia(Nodo) const;
                 ^~~~
..\src\alberopt.h:24:5: error: 'Nodo' does not name a type
     Nodo primoFiglio(Nodo) const;
     ^~~~
..\src\alberopt.h:24:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:25:25: error: 'Nodo' has not been declared
     bool ultimoFratello(Nodo) const;
                         ^~~~
..\src\alberopt.h:26:5: error: 'Nodo' does not name a type
     Nodo fratelloSuccessivo(Nodo) const;
     ^~~~
..\src\alberopt.h:26:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:27:36: error: 'Nodo' has not been declared
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                    ^~~~
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:78: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                              ^
..\src\alberopt.h:27:78: error: template argument 2 is invalid
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:27:79: error: template argument 2 is invalid
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:27:79: error: template argument 2 is invalid
..\src\alberopt.h:27:42: error: 'Albero' is not a type
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                          ^~~~~~
..\src\alberopt.h:27:48: error: expected ',' or '...' before '<' token
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                ^
..\src\alberopt.h:28:31: error: 'Nodo' has not been declared
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                               ^~~~
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:73: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                         ^
..\src\alberopt.h:28:73: error: template argument 2 is invalid
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:28:74: error: template argument 2 is invalid
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:28:74: error: template argument 2 is invalid
..\src\alberopt.h:28:37: error: 'Albero' is not a type
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                     ^~~~~~
..\src\alberopt.h:28:43: error: expected ',' or '...' before '<' token
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                           ^
..\src\alberopt.h:29:30: error: 'Nodo' has not been declared
     void cancellaSottoalbero(Nodo);
                              ^~~~
..\src\alberopt.h:30:21: error: 'Nodo' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                     ^~~~
..\src\alberopt.h:30:27: error: 'TipoElemento' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                           ^~~~~~~~~~~~
..\src\alberopt.h:31:5: error: 'TipoElemento' does not name a type
     TipoElemento leggiNodo(Nodo) const;
     ^~~~~~~~~~~~
..\src\alberopt.h:31:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::TipoElemento' was intended)
..\src\alberopt.h:33:31: error: 'Nodo' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                               ^~~~
..\src\alberopt.h:33:37: error: 'TipoElemento' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                                     ^~~~~~~~~~~~
..\src\alberopt.h:34:28: error: 'Nodo' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                            ^~~~
..\src\alberopt.h:34:34: error: 'TipoElemento' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                                  ^~~~~~~~~~~~
..\src\alberopt.h:38:5: error: 'Nodo' does not name a type
     Nodo radice;
     ^~~~
..\src\alberopt.h:38:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:40:16: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                ^~~~
..\src\alberopt.h:40:22: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                      ^~~~
..\src\alberopt.h:41:17: error: 'Nodo' has not been declared
     void stampa(Nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'AlberoPt<T>::~AlberoPt()':
..\src\alberopt.h:47:29: error: 'radice' was not declared in this scope
         cancellaSottoalbero(radice);
                             ^~~~~~
..\src\alberopt.h: In constructor 'AlberoPt<T>::AlberoPt()':
..\src\alberopt.h:53:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: In copy constructor 'AlberoPt<T>::AlberoPt(const AlberoPt<T>&)':
..\src\alberopt.h:59:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:67:25: error: variable or field 'copia' declared void
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:67:25: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:67:33: error: 'Nodo' was not declared in this scope
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h: In member function 'bool AlberoPt<T>::vuoto() const':
..\src\alberopt.h:81:12: error: 'radice' was not declared in this scope
     return radice.listaVuota();
            ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:85:35: error: variable or field 'inserisciRadice' declared void
 void AlberoPt<T>::inserisciRadice(TipoElemento e) {
                                   ^~~~~~~~~~~~
..\src\alberopt.h:85:35: error: 'TipoElemento' was not declared in this scope
..\src\alberopt.h:93:55: error: no 'typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const' member function declared in class 'AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:101:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                        ^~~~
..\src\alberopt.h:101:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:101:48: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                                ^~~~~~~~~~~~
..\src\alberopt.h:108:37: error: variable or field 'inserisciFratello' declared void
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                     ^~~~
..\src\alberopt.h:108:37: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:108:45: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                             ^~~~~~~~~~~~
..\src\alberopt.h:118:30: error: variable or field 'scriviNodo' declared void
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                              ^~~~
..\src\alberopt.h:118:30: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:118:38: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                                      ^~~~~~~~~~~~
..\src\alberopt.h:125:59: error: 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(Nodo n) const {
                                                           ^~~~
..\src\alberopt.h:125:59: error: template definition of non-template 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo'
..\src\alberopt.h:125:59: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:134:50: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::genitore(Nodo n) const {
                                                  ^~~~
..\src\alberopt.h:134:50: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore'
..\src\alberopt.h:134:50: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:145:26: error: 'bool AlberoPt<T>::foglia' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::foglia(Nodo n) const {
                          ^~~~
..\src\alberopt.h:145:26: error: template definition of non-template 'bool AlberoPt<T>::foglia'
..\src\alberopt.h:145:26: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:153:53: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(Nodo n) const {
                                                     ^~~~
..\src\alberopt.h:153:53: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio'
..\src\alberopt.h:153:53: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:164:34: error: 'bool AlberoPt<T>::ultimoFratello' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::ultimoFratello(Nodo n) const {
                                  ^~~~
..\src\alberopt.h:164:34: error: template definition of non-template 'bool AlberoPt<T>::ultimoFratello'
..\src\alberopt.h:164:34: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:172:60: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo(Nodo n) const {
                                                            ^~~~
..\src\alberopt.h:172:60: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:172:60: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:183:45: error: variable or field 'inserisciPrimoSottoalbero' declared void
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                             ^~~~
..\src\alberopt.h:183:45: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:183:60: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                            ^~~~~~~~~~~~
..\src\alberopt.h:183:74: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:183:89: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:183:89: error: template argument 2 is invalid
..\src\alberopt.h:183:94: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                              ^
..\src\alberopt.h:196:40: error: variable or field 'inserisciSottoalbero' declared void
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                        ^~~~
..\src\alberopt.h:196:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:196:55: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                       ^~~~~~~~~~~~
..\src\alberopt.h:196:69: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                     ^~~~~~~~~~~~~~
..\src\alberopt.h:196:84: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                    ^
..\src\alberopt.h:196:84: error: template argument 2 is invalid
..\src\alberopt.h:196:89: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:212:39: error: variable or field 'cancellaSottoalbero' declared void
 void AlberoPt<T>::cancellaSottoalbero(Nodo n) {
                                       ^~~~
..\src\alberopt.h:212:39: error: 'Nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void AlberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:230:16: error: 'radice' was not declared in this scope
         stampa(radice);
                ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:237:26: error: variable or field 'stampa' declared void
 void AlberoPt<T>::stampa(Nodo n) const {
                          ^~~~
..\src\alberopt.h:237:26: error: 'Nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:47:13 **** Rebuild of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:47:13 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:12:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:12:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                               ^
..\src\alberopt.h:12:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:13:32: error: 'ListaPuntatore' was not declared in this scope
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                ^~~~~~~~~~~~~~
..\src\alberopt.h:13:47: error: template argument 2 is invalid
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                               ^
..\src\alberopt.h:13:22: error: expected nested-name-specifier
     typedef typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:20:26: error: 'TipoElemento' has not been declared
     void inserisciRadice(TipoElemento);
                          ^~~~~~~~~~~~
..\src\alberopt.h:21:5: error: 'Nodo' does not name a type
     Nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:21:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:22:5: error: 'Nodo' does not name a type
     Nodo genitore(Nodo) const;
     ^~~~
..\src\alberopt.h:22:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:23:17: error: 'Nodo' has not been declared
     bool foglia(Nodo) const;
                 ^~~~
..\src\alberopt.h:24:5: error: 'Nodo' does not name a type
     Nodo primoFiglio(Nodo) const;
     ^~~~
..\src\alberopt.h:24:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:25:25: error: 'Nodo' has not been declared
     bool ultimoFratello(Nodo) const;
                         ^~~~
..\src\alberopt.h:26:5: error: 'Nodo' does not name a type
     Nodo fratelloSuccessivo(Nodo) const;
     ^~~~
..\src\alberopt.h:26:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:27:36: error: 'Nodo' has not been declared
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                    ^~~~
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:78: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                              ^
..\src\alberopt.h:27:78: error: template argument 2 is invalid
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:27:79: error: template argument 2 is invalid
..\src\alberopt.h:27:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:27:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:27:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:27:79: error: template argument 2 is invalid
..\src\alberopt.h:27:42: error: 'Albero' is not a type
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                          ^~~~~~
..\src\alberopt.h:27:48: error: expected ',' or '...' before '<' token
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                ^
..\src\alberopt.h:28:31: error: 'Nodo' has not been declared
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                               ^~~~
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:73: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                         ^
..\src\alberopt.h:28:73: error: template argument 2 is invalid
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:28:74: error: template argument 2 is invalid
..\src\alberopt.h:28:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:28:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:28:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:28:74: error: template argument 2 is invalid
..\src\alberopt.h:28:37: error: 'Albero' is not a type
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                     ^~~~~~
..\src\alberopt.h:28:43: error: expected ',' or '...' before '<' token
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                           ^
..\src\alberopt.h:29:30: error: 'Nodo' has not been declared
     void cancellaSottoalbero(Nodo);
                              ^~~~
..\src\alberopt.h:30:21: error: 'Nodo' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                     ^~~~
..\src\alberopt.h:30:27: error: 'TipoElemento' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                           ^~~~~~~~~~~~
..\src\alberopt.h:31:5: error: 'TipoElemento' does not name a type
     TipoElemento leggiNodo(Nodo) const;
     ^~~~~~~~~~~~
..\src\alberopt.h:31:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::TipoElemento' was intended)
..\src\alberopt.h:33:31: error: 'Nodo' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                               ^~~~
..\src\alberopt.h:33:37: error: 'TipoElemento' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                                     ^~~~~~~~~~~~
..\src\alberopt.h:34:28: error: 'Nodo' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                            ^~~~
..\src\alberopt.h:34:34: error: 'TipoElemento' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                                  ^~~~~~~~~~~~
..\src\alberopt.h:38:5: error: 'Nodo' does not name a type
     Nodo radice;
     ^~~~
..\src\alberopt.h:38:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:40:16: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                ^~~~
..\src\alberopt.h:40:22: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                      ^~~~
..\src\alberopt.h:41:17: error: 'Nodo' has not been declared
     void stampa(Nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'AlberoPt<T>::~AlberoPt()':
..\src\alberopt.h:47:29: error: 'radice' was not declared in this scope
         cancellaSottoalbero(radice);
                             ^~~~~~
..\src\alberopt.h: In constructor 'AlberoPt<T>::AlberoPt()':
..\src\alberopt.h:53:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: In copy constructor 'AlberoPt<T>::AlberoPt(const AlberoPt<T>&)':
..\src\alberopt.h:59:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:67:25: error: variable or field 'copia' declared void
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:67:25: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:67:33: error: 'Nodo' was not declared in this scope
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h: In member function 'bool AlberoPt<T>::vuoto() const':
..\src\alberopt.h:81:12: error: 'radice' was not declared in this scope
     return radice.listaVuota();
            ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:85:35: error: variable or field 'inserisciRadice' declared void
 void AlberoPt<T>::inserisciRadice(TipoElemento e) {
                                   ^~~~~~~~~~~~
..\src\alberopt.h:85:35: error: 'TipoElemento' was not declared in this scope
..\src\alberopt.h:93:55: error: no 'typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const' member function declared in class 'AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:101:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                        ^~~~
..\src\alberopt.h:101:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:101:48: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                                ^~~~~~~~~~~~
..\src\alberopt.h:108:37: error: variable or field 'inserisciFratello' declared void
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                     ^~~~
..\src\alberopt.h:108:37: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:108:45: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                             ^~~~~~~~~~~~
..\src\alberopt.h:118:30: error: variable or field 'scriviNodo' declared void
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                              ^~~~
..\src\alberopt.h:118:30: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:118:38: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                                      ^~~~~~~~~~~~
..\src\alberopt.h:125:59: error: 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(Nodo n) const {
                                                           ^~~~
..\src\alberopt.h:125:59: error: template definition of non-template 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo'
..\src\alberopt.h:125:59: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:134:50: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::genitore(Nodo n) const {
                                                  ^~~~
..\src\alberopt.h:134:50: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore'
..\src\alberopt.h:134:50: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:145:26: error: 'bool AlberoPt<T>::foglia' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::foglia(Nodo n) const {
                          ^~~~
..\src\alberopt.h:145:26: error: template definition of non-template 'bool AlberoPt<T>::foglia'
..\src\alberopt.h:145:26: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:153:53: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(Nodo n) const {
                                                     ^~~~
..\src\alberopt.h:153:53: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio'
..\src\alberopt.h:153:53: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:164:34: error: 'bool AlberoPt<T>::ultimoFratello' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::ultimoFratello(Nodo n) const {
                                  ^~~~
..\src\alberopt.h:164:34: error: template definition of non-template 'bool AlberoPt<T>::ultimoFratello'
..\src\alberopt.h:164:34: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:172:60: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo(Nodo n) const {
                                                            ^~~~
..\src\alberopt.h:172:60: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:172:60: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:183:45: error: variable or field 'inserisciPrimoSottoalbero' declared void
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                             ^~~~
..\src\alberopt.h:183:45: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:183:60: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                            ^~~~~~~~~~~~
..\src\alberopt.h:183:74: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:183:89: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:183:89: error: template argument 2 is invalid
..\src\alberopt.h:183:94: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                              ^
..\src\alberopt.h:196:40: error: variable or field 'inserisciSottoalbero' declared void
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                        ^~~~
..\src\alberopt.h:196:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:196:55: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                       ^~~~~~~~~~~~
..\src\alberopt.h:196:69: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                     ^~~~~~~~~~~~~~
..\src\alberopt.h:196:84: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                    ^
..\src\alberopt.h:196:84: error: template argument 2 is invalid
..\src\alberopt.h:196:89: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:212:39: error: variable or field 'cancellaSottoalbero' declared void
 void AlberoPt<T>::cancellaSottoalbero(Nodo n) {
                                       ^~~~
..\src\alberopt.h:212:39: error: 'Nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void AlberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:230:16: error: 'radice' was not declared in this scope
         stampa(radice);
                ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:237:26: error: variable or field 'stampa' declared void
 void AlberoPt<T>::stampa(Nodo n) const {
                          ^~~~
..\src\alberopt.h:237:26: error: 'Nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:48:36 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:48:37 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:13:24: error: 'ListaPuntatore' was not declared in this scope
     typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                        ^~~~~~~~~~~~~~
..\src\alberopt.h:13:39: error: template argument 2 is invalid
     typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
                                       ^
..\src\alberopt.h:13:14: error: expected nested-name-specifier
     typename Albero<T, ListaPuntatore<T>>::TipoElemento TipoElemento;
              ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:14:24: error: 'ListaPuntatore' was not declared in this scope
     typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                        ^~~~~~~~~~~~~~
..\src\alberopt.h:14:39: error: template argument 2 is invalid
     typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
                                       ^
..\src\alberopt.h:14:14: error: expected nested-name-specifier
     typename Albero<T, ListaPuntatore<T>>::NodoAlbero Nodo;
              ^~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberopt.h:21:26: error: 'TipoElemento' has not been declared
     void inserisciRadice(TipoElemento);
                          ^~~~~~~~~~~~
..\src\alberopt.h:22:5: error: 'Nodo' does not name a type
     Nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:22:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:23:5: error: 'Nodo' does not name a type
     Nodo genitore(Nodo) const;
     ^~~~
..\src\alberopt.h:23:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:24:17: error: 'Nodo' has not been declared
     bool foglia(Nodo) const;
                 ^~~~
..\src\alberopt.h:25:5: error: 'Nodo' does not name a type
     Nodo primoFiglio(Nodo) const;
     ^~~~
..\src\alberopt.h:25:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:26:25: error: 'Nodo' has not been declared
     bool ultimoFratello(Nodo) const;
                         ^~~~
..\src\alberopt.h:27:5: error: 'Nodo' does not name a type
     Nodo fratelloSuccessivo(Nodo) const;
     ^~~~
..\src\alberopt.h:27:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:28:36: error: 'Nodo' has not been declared
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                    ^~~~
..\src\alberopt.h:28:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:28:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:28:78: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                              ^
..\src\alberopt.h:28:78: error: template argument 2 is invalid
..\src\alberopt.h:28:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:28:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:28:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:28:79: error: template argument 2 is invalid
..\src\alberopt.h:28:49: error: 'TipoElemento' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                 ^~~~~~~~~~~~
..\src\alberopt.h:28:63: error: 'ListaPuntatore' was not declared in this scope
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                               ^~~~~~~~~~~~~~
..\src\alberopt.h:28:79: error: template argument 1 is invalid
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                               ^~
..\src\alberopt.h:28:79: error: template argument 2 is invalid
..\src\alberopt.h:28:42: error: 'Albero' is not a type
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                          ^~~~~~
..\src\alberopt.h:28:48: error: expected ',' or '...' before '<' token
     void inserisciPrimoSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                ^
..\src\alberopt.h:29:31: error: 'Nodo' has not been declared
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                               ^~~~
..\src\alberopt.h:29:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:29:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:29:73: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                         ^
..\src\alberopt.h:29:73: error: template argument 2 is invalid
..\src\alberopt.h:29:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:29:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:29:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:29:74: error: template argument 2 is invalid
..\src\alberopt.h:29:44: error: 'TipoElemento' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                            ^~~~~~~~~~~~
..\src\alberopt.h:29:58: error: 'ListaPuntatore' was not declared in this scope
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:29:74: error: template argument 1 is invalid
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                                                          ^~
..\src\alberopt.h:29:74: error: template argument 2 is invalid
..\src\alberopt.h:29:37: error: 'Albero' is not a type
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                     ^~~~~~
..\src\alberopt.h:29:43: error: expected ',' or '...' before '<' token
     void inserisciSottoalbero(Nodo, Albero<TipoElemento, ListaPuntatore<T>> &);
                                           ^
..\src\alberopt.h:30:30: error: 'Nodo' has not been declared
     void cancellaSottoalbero(Nodo);
                              ^~~~
..\src\alberopt.h:31:21: error: 'Nodo' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                     ^~~~
..\src\alberopt.h:31:27: error: 'TipoElemento' has not been declared
     void scriviNodo(Nodo, TipoElemento);
                           ^~~~~~~~~~~~
..\src\alberopt.h:32:5: error: 'TipoElemento' does not name a type
     TipoElemento leggiNodo(Nodo) const;
     ^~~~~~~~~~~~
..\src\alberopt.h:32:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::TipoElemento' was intended)
..\src\alberopt.h:34:31: error: 'Nodo' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                               ^~~~
..\src\alberopt.h:34:37: error: 'TipoElemento' has not been declared
     void inserisciPrimoFiglio(Nodo, TipoElemento);
                                     ^~~~~~~~~~~~
..\src\alberopt.h:35:28: error: 'Nodo' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                            ^~~~
..\src\alberopt.h:35:34: error: 'TipoElemento' has not been declared
     void inserisciFratello(Nodo, TipoElemento);
                                  ^~~~~~~~~~~~
..\src\alberopt.h:39:5: error: 'Nodo' does not name a type
     Nodo radice;
     ^~~~
..\src\alberopt.h:39:5: note: (perhaps 'typename Albero<T, listaPuntatore<T> >::Nodo' was intended)
..\src\alberopt.h:41:16: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                ^~~~
..\src\alberopt.h:41:22: error: 'Nodo' has not been declared
     void copia(Nodo, Nodo);
                      ^~~~
..\src\alberopt.h:42:17: error: 'Nodo' has not been declared
     void stampa(Nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'AlberoPt<T>::~AlberoPt()':
..\src\alberopt.h:48:29: error: 'radice' was not declared in this scope
         cancellaSottoalbero(radice);
                             ^~~~~~
..\src\alberopt.h: In constructor 'AlberoPt<T>::AlberoPt()':
..\src\alberopt.h:54:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: In copy constructor 'AlberoPt<T>::AlberoPt(const AlberoPt<T>&)':
..\src\alberopt.h:60:5: error: 'radice' was not declared in this scope
     radice.creaLista();
     ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:68:25: error: variable or field 'copia' declared void
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:68:25: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:68:33: error: 'Nodo' was not declared in this scope
 void AlberoPt<T>::copia(Nodo n, Nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h: In member function 'bool AlberoPt<T>::vuoto() const':
..\src\alberopt.h:82:12: error: 'radice' was not declared in this scope
     return radice.listaVuota();
            ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:86:35: error: variable or field 'inserisciRadice' declared void
 void AlberoPt<T>::inserisciRadice(TipoElemento e) {
                                   ^~~~~~~~~~~~
..\src\alberopt.h:86:35: error: 'TipoElemento' was not declared in this scope
..\src\alberopt.h:94:55: error: no 'typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const' member function declared in class 'AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:102:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                        ^~~~
..\src\alberopt.h:102:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:102:48: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoFiglio(Nodo n, TipoElemento e) {
                                                ^~~~~~~~~~~~
..\src\alberopt.h:109:37: error: variable or field 'inserisciFratello' declared void
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                     ^~~~
..\src\alberopt.h:109:37: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:109:45: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciFratello(Nodo n, TipoElemento e) {
                                             ^~~~~~~~~~~~
..\src\alberopt.h:119:30: error: variable or field 'scriviNodo' declared void
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                              ^~~~
..\src\alberopt.h:119:30: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:119:38: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::scriviNodo(Nodo n, TipoElemento e) {
                                      ^~~~~~~~~~~~
..\src\alberopt.h:126:59: error: 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(Nodo n) const {
                                                           ^~~~
..\src\alberopt.h:126:59: error: template definition of non-template 'typename AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo'
..\src\alberopt.h:126:59: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:135:50: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::genitore(Nodo n) const {
                                                  ^~~~
..\src\alberopt.h:135:50: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::genitore'
..\src\alberopt.h:135:50: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:146:26: error: 'bool AlberoPt<T>::foglia' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::foglia(Nodo n) const {
                          ^~~~
..\src\alberopt.h:146:26: error: template definition of non-template 'bool AlberoPt<T>::foglia'
..\src\alberopt.h:146:26: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:154:53: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(Nodo n) const {
                                                     ^~~~
..\src\alberopt.h:154:53: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio'
..\src\alberopt.h:154:53: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:165:34: error: 'bool AlberoPt<T>::ultimoFratello' is not a static data member of 'class AlberoPt<T>'
 bool AlberoPt<T>::ultimoFratello(Nodo n) const {
                                  ^~~~
..\src\alberopt.h:165:34: error: template definition of non-template 'bool AlberoPt<T>::ultimoFratello'
..\src\alberopt.h:165:34: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:173:60: error: 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo' is not a static data member of 'class AlberoPt<T>'
 typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo(Nodo n) const {
                                                            ^~~~
..\src\alberopt.h:173:60: error: template definition of non-template 'typename AlberoPt<T>::Nodo AlberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:173:60: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:184:45: error: variable or field 'inserisciPrimoSottoalbero' declared void
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                             ^~~~
..\src\alberopt.h:184:45: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:184:60: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                            ^~~~~~~~~~~~
..\src\alberopt.h:184:74: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                          ^~~~~~~~~~~~~~
..\src\alberopt.h:184:89: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:184:89: error: template argument 2 is invalid
..\src\alberopt.h:184:94: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciPrimoSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                              ^
..\src\alberopt.h:197:40: error: variable or field 'inserisciSottoalbero' declared void
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                        ^~~~
..\src\alberopt.h:197:40: error: 'Nodo' was not declared in this scope
..\src\alberopt.h:197:55: error: 'TipoElemento' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                       ^~~~~~~~~~~~
..\src\alberopt.h:197:69: error: 'ListaPuntatore' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                     ^~~~~~~~~~~~~~
..\src\alberopt.h:197:84: error: template argument 1 is invalid
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                    ^
..\src\alberopt.h:197:84: error: template argument 2 is invalid
..\src\alberopt.h:197:89: error: 'a' was not declared in this scope
 void AlberoPt<T>::inserisciSottoalbero(Nodo n, Albero<TipoElemento, ListaPuntatore<T>> &a) {
                                                                                         ^
..\src\alberopt.h:213:39: error: variable or field 'cancellaSottoalbero' declared void
 void AlberoPt<T>::cancellaSottoalbero(Nodo n) {
                                       ^~~~
..\src\alberopt.h:213:39: error: 'Nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void AlberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:231:16: error: 'radice' was not declared in this scope
         stampa(radice);
                ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:238:26: error: variable or field 'stampa' declared void
 void AlberoPt<T>::stampa(Nodo n) const {
                          ^~~~
..\src\alberopt.h:238:26: error: 'Nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:55:35 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:55:36 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:25:10: error: stray '\303' in program
     bool èUltimoFratello(Nodo) const;
          ^
..\src\alberopt.h:25:11: error: stray '\250' in program
     bool èUltimoFratello(Nodo) const;
           ^
..\src\alberopt.h:165:19: error: stray '\303' in program
 bool AlberoPt<T>::èUltimoFratello(Nodo n) const {
                   ^
..\src\alberopt.h:165:20: error: stray '\250' in program
 bool AlberoPt<T>::èUltimoFratello(Nodo n) const {
                    ^
..\src\alberopt.h:250:17: error: stray '\303' in program
         while (!èUltimoFratello(c)) {
                 ^
..\src\alberopt.h:250:18: error: stray '\250' in program
         while (!èUltimoFratello(c)) {
                  ^
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:55:51 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:55:51 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:55:59 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:55:59 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:5:5: error: 'treePt' was not declared in this scope
     treePt<int> myTree;
     ^~~~~~
..\src\testTree.cpp:5:12: error: expected primary-expression before 'int'
     treePt<int> myTree;
            ^~~
..\src\testTree.cpp:8:5: error: 'myTree' was not declared in this scope
     myTree.insertRoot(1);
     ^~~~~~
..\src\testTree.cpp:11:12: error: expected primary-expression before 'int'
     treePt<int>::Node root = myTree.readRoot();
            ^~~
..\src\testTree.cpp:12:29: error: 'root' was not declared in this scope
     myTree.insertFirstChild(root, 2);
                             ^~~~
..\src\testTree.cpp:16:12: error: expected primary-expression before 'int'
     treePt<int> subtree;
            ^~~
..\src\testTree.cpp:17:5: error: 'subtree' was not declared in this scope
     subtree.insertRoot(4);
     ^~~~~~~
..\src\testTree.cpp:27:12: error: expected primary-expression before 'int'
     treePt<int>::Node child = myTree.firstChild(root);
            ^~~
..\src\testTree.cpp:28:61: error: 'child' was not declared in this scope
     std::cout << "First child of root: " << myTree.readNode(child) << std::endl;
                                                             ^~~~~
23:56:59 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
23:57:00 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
..\src\testTree.cpp:27:52: error: stray '\303' in program
     std::cout << "È foglia il nodo 6: " << albero.èFoglia(albero.prossimoFratello(sottoAlbero)) << std::endl;
                                                    ^
..\src\testTree.cpp:27:53: error: stray '\250' in program
     std::cout << "È foglia il nodo 6: " << albero.èFoglia(albero.prossimoFratello(sottoAlbero)) << std::endl;
                                                     ^
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:4:19: error: cannot declare variable 'albero' to be of abstract type 'AlberoPt<int>'
     AlberoPt<int> albero;
                   ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:10:7: note:   because the following virtual functions are pure within 'AlberoPt<int>':
 class AlberoPt : public Albero<T, NodoAlbero<T> *> {
       ^~~~~~~~
In file included from ..\src\alberopt.h:1:0,
                 from ..\src\testTree.cpp:1:
..\src\Albero.h:22:18: note: 	Albero<I, N>::Nodo Albero<I, N>::fratelloSuccessivo(Albero<I, N>::Nodo) const [with I = int; N = NodoAlbero<int>*; Albero<I, N>::Nodo = NodoAlbero<int>*]
     virtual Nodo fratelloSuccessivo(Nodo) const = 0;
                  ^~~~~~~~~~~~~~~~~~
..\src\Albero.h:23:18: note: 	void Albero<I, N>::inserisciPrimoSottoalbero(Albero<I, N>::Nodo, Albero<I, N>&) [with I = int; N = NodoAlbero<int>*; Albero<I, N>::Nodo = NodoAlbero<int>*]
     virtual void inserisciPrimoSottoalbero(Nodo, Albero<I, N> &) = 0;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~
..\src\Albero.h:24:18: note: 	void Albero<I, N>::inserisciSottoalbero(Albero<I, N>::Nodo, Albero<I, N>&) [with I = int; N = NodoAlbero<int>*; Albero<I, N>::Nodo = NodoAlbero<int>*]
     virtual void inserisciSottoalbero(Nodo, Albero<I, N> &) = 0;
                  ^~~~~~~~~~~~~~~~~~~~
..\src\Albero.h:25:18: note: 	void Albero<I, N>::cancellaSottoalbero(Albero<I, N>::Nodo) [with I = int; N = NodoAlbero<int>*; Albero<I, N>::Nodo = NodoAlbero<int>*]
     virtual void cancellaSottoalbero(Nodo) = 0;
                  ^~~~~~~~~~~~~~~~~~~
..\src\testTree.cpp:14:61: error: invalid cast to abstract class type 'AlberoPt<int>'
     albero.inserisciPrimoSottoAlbero(figlio1, AlberoPt<int>());
                                                             ^
..\src\testTree.cpp:27:54: error: 'class AlberoPt<int>' has no member named 'Foglia'; did you mean 'foglia'?
     std::cout << "È foglia il nodo 6: " << albero.èFoglia(albero.prossimoFratello(sottoAlbero)) << std::endl;
                                                      ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::inserisciRadice(AlberoPt<T>::TipoElemento) [with T = int; AlberoPt<T>::TipoElemento = int]':
..\src\testTree.cpp:7:29:   required from here
..\src\alberopt.h:85:17: error: 'int NodoAlbero<int>::valore' is private within this context
         radice->valore(e);
         ~~~~~~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:85:9: error: expression cannot be used as a function
         radice->valore(e);
         ^~~~~~
..\src\alberopt.h:86:17: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
         radice->fratello(nullptr);
         ~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:86:9: error: expression cannot be used as a function
         radice->fratello(nullptr);
         ^~~~~~
..\src\alberopt.h:87:17: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
         radice->genitore(nullptr);
         ~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:87:9: error: expression cannot be used as a function
         radice->genitore(nullptr);
         ^~~~~~
..\src\alberopt.h:88:17: error: 'class NodoAlbero<int>' has no member named 'figlio'
         radice->figlio(nullptr);
         ~~~~~~~~^~~~~~
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::inserisciPrimoFiglio(AlberoPt<T>::Nodo, AlberoPt<T>::TipoElemento) [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*; AlberoPt<T>::TipoElemento = int]':
..\src\testTree.cpp:9:42:   required from here
..\src\alberopt.h:104:16: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
     nuovoNodo->fratello(n->figlio());
     ~~~~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:104:28: error: 'class NodoAlbero<int>' has no member named 'figlio'
     nuovoNodo->fratello(n->figlio());
                         ~~~^~~~~~
..\src\alberopt.h:104:5: error: expression cannot be used as a function
     nuovoNodo->fratello(n->figlio());
     ^~~~~~~~~
..\src\alberopt.h:105:8: error: 'class NodoAlbero<int>' has no member named 'figlio'
     n->figlio(nuovoNodo);
     ~~~^~~~~~
..\src\alberopt.h:106:16: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
     nuovoNodo->genitore(n);
     ~~~~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:106:5: error: expression cannot be used as a function
     nuovoNodo->genitore(n);
     ^~~~~~~~~
..\src\alberopt.h:107:16: error: 'int NodoAlbero<int>::valore' is private within this context
     nuovoNodo->valore(e);
     ~~~~~~~~~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:107:5: error: expression cannot be used as a function
     nuovoNodo->valore(e);
     ^~~~~~~~~
..\src\alberopt.h: In instantiation of 'AlberoPt<T>::Nodo AlberoPt<T>::primoFiglio(AlberoPt<T>::Nodo) const [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\testTree.cpp:10:45:   required from here
..\src\alberopt.h:156:16: error: 'class NodoAlbero<int>' has no member named 'figlio'
         if (n->figlio() != nullptr) {
             ~~~^~~~~~
..\src\alberopt.h:157:23: error: 'class NodoAlbero<int>' has no member named 'figlio'
             return n->figlio();
                    ~~~^~~~~~
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::inserisci(AlberoPt<T>::Nodo, AlberoPt<T>::TipoElemento) [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*; AlberoPt<T>::TipoElemento = int]':
..\src\testTree.cpp:11:32:   required from here
..\src\alberopt.h:115:20: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
         nuovoNodo->fratello(n->fratello());
         ~~~~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:115:32: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
         nuovoNodo->fratello(n->fratello());
                             ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:115:9: error: expression cannot be used as a function
         nuovoNodo->fratello(n->fratello());
         ^~~~~~~~~
..\src\alberopt.h:115:9: error: expression cannot be used as a function
..\src\alberopt.h:116:12: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
         n->fratello(nuovoNodo);
         ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:116:9: error: expression cannot be used as a function
         n->fratello(nuovoNodo);
         ^
..\src\alberopt.h:117:20: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
         nuovoNodo->genitore(n->genitore());
         ~~~~~~~~~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:117:32: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
         nuovoNodo->genitore(n->genitore());
                             ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:117:9: error: expression cannot be used as a function
         nuovoNodo->genitore(n->genitore());
         ^~~~~~~~~
..\src\alberopt.h:117:9: error: expression cannot be used as a function
..\src\alberopt.h:118:20: error: 'int NodoAlbero<int>::valore' is private within this context
         nuovoNodo->valore(e);
         ~~~~~~~~~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:118:9: error: expression cannot be used as a function
         nuovoNodo->valore(e);
         ^~~~~~~~~
..\src\alberopt.h: In instantiation of 'AlberoPt<T>::TipoElemento AlberoPt<T>::leggiNodo(AlberoPt<T>::Nodo) const [with T = int; AlberoPt<T>::TipoElemento = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\testTree.cpp:24:68:   required from here
..\src\alberopt.h:131:15: error: 'int NodoAlbero<int>::valore' is private within this context
     return n->valore();
            ~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:131:22: error: expression cannot be used as a function
     return n->valore();
                      ^
..\src\alberopt.h: In instantiation of 'AlberoPt<T>::Nodo AlberoPt<T>::genitore(AlberoPt<T>::Nodo) const [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\testTree.cpp:25:105:   required from here
..\src\alberopt.h:137:16: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
         if (n->genitore() != nullptr) {
             ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:137:27: error: expression cannot be used as a function
         if (n->genitore() != nullptr) {
                            
..\src\alberopt.h:138:23: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
             return n->genitore();
                    ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:138:32: error: expression cannot be used as a function
             return n->genitore();
                                ^
..\src\alberopt.h: In instantiation of 'AlberoPt<T>::Nodo AlberoPt<T>::prossimoFratello(AlberoPt<T>::Nodo) const [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\testTree.cpp:27:96:   required from here
..\src\alberopt.h:175:16: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
         if (n->fratello() != nullptr) {
             ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:175:27: error: expression cannot be used as a function
         if (n->fratello() != nullptr) {
                            
..\src\alberopt.h:176:23: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
             return n->fratello();
                    ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:176:32: error: expression cannot be used as a function
             return n->fratello();
                                ^
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::cancellaSottoAlbero(AlberoPt<T>::Nodo) [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\alberopt.h:46:41:   required from 'AlberoPt<T>::~AlberoPt() [with T = int]'
..\src\testTree.cpp:4:19:   required from here
..\src\alberopt.h:219:19: error: 'class NodoAlbero<int>' has no member named 'figlio'
         while (n->figlio() != nullptr) {
                ~~~^~~~~~
..\src\alberopt.h:220:36: error: 'class NodoAlbero<int>' has no member named 'figlio'
             cancellaSottoAlbero(n->figlio());
                                 ~~~^~~~~~
..\src\alberopt.h:223:20: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
             if (n->fratello() == nullptr)
                 ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:223:31: error: expression cannot be used as a function
             if (n->fratello() == nullptr)
                                
..\src\alberopt.h:224:20: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
                 n->genitore()->figlio()->fratello(nullptr);
                 ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:224:17: error: expression cannot be used as a function
                 n->genitore()->figlio()->fratello(nullptr);
                 ^
..\src\alberopt.h:225:20: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
             if (n->genitore()->figlio() == n)
                 ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:225:17: error: expression cannot be used as a function
             if (n->genitore()->figlio() == n)
                 ^
..\src\alberopt.h:226:20: error: 'NodoAlbero<int>* NodoAlbero<int>::genitore' is private within this context
                 n->genitore()->figlio(n->fratello());
                 ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:5:20: note: declared private here
     NodoAlbero<T>* genitore;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:226:17: error: expression cannot be used as a function
                 n->genitore()->figlio(n->fratello());
                 ^
..\src\alberopt.h:226:42: error: 'NodoAlbero<int>* NodoAlbero<int>::fratello' is private within this context
                 n->genitore()->figlio(n->fratello());
                                       ~~~^~~~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:7:20: note: declared private here
     NodoAlbero<T>* fratello;
                    ^~~~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:226:17: error: expression cannot be used as a function
                 n->genitore()->figlio(n->fratello());
                 ^
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::stampa(AlberoPt<T>::Nodo) const [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*]':
..\src\alberopt.h:238:15:   required from 'void AlberoPt<T>::stampaAlbero() const [with T = int]'
..\src\testTree.cpp:20:25:   required from here
..\src\alberopt.h:247:25: error: 'int NodoAlbero<int>::valore' is private within this context
         std::cout << n->valore() << " ";
                      ~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:247:19: error: expression cannot be used as a function
         std::cout << n->valore() << " ";
                    
..\src\alberopt.h: In instantiation of 'void AlberoPt<T>::scriviNodo(AlberoPt<T>::Nodo, AlberoPt<T>::TipoElemento) [with T = int; AlberoPt<T>::Nodo = NodoAlbero<int>*; AlberoPt<T>::TipoElemento = int]':
..\src\testTree.cpp:30:1:   required from here
..\src\alberopt.h:126:8: error: 'int NodoAlbero<int>::valore' is private within this context
     n->valore(e);
     ~~~^~~~~~
In file included from ..\src\alberopt.h:2:0,
                 from ..\src\testTree.cpp:1:
..\src\NodoAlbero.h:4:7: note: declared private here
     T valore;
       ^~~~~~
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:126:5: error: expression cannot be used as a function
     n->valore(e);
     ^
00:06:23 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
00:06:23 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
..\src\testTree.cpp:27:52: error: stray '\303' in program
     std::cout << "È foglia il nodo 6: " << albero.èFoglia(albero.prossimoFratello(sottoAlbero)) << std::endl;
                                                    ^
..\src\testTree.cpp:27:53: error: stray '\250' in program
     std::cout << "È foglia il nodo 6: " << albero.èFoglia(albero.prossimoFratello(sottoAlbero)) << std::endl;
                                                     ^
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h:12:32: error: 'nodoT' was not declared in this scope
     typedef typename Albero<T, nodoT<T> *>::tipoElem tipoElem;
                                ^~~~~
..\src\alberopt.h:12:39: error: template argument 2 is invalid
     typedef typename Albero<T, nodoT<T> *>::tipoElem tipoElem;
                                       ^
..\src\alberopt.h:12:22: error: expected nested-name-specifier
     typedef typename Albero<T, nodoT<T> *>::tipoElem tipoElem;
                      ^~~~~~~~~~~~~~~~~~
..\src\alberopt.h:13:32: error: 'nodoT' was not declared in this scope
     typedef typename Albero<T, nodoT<T> *>::nodo nodo;
                                ^~~~~
..\src\alberopt.h:13:39: error: template argument 2 is invalid
     typedef typename Albero<T, nodoT<T> *>::nodo nodo;
                                       ^
..\src\alberopt.h:13:22: error: expected nested-name-specifier
     typedef typename Albero<T, nodoT<T> *>::nodo nodo;
                      ^~~~~~~~~~~~~~~~~~
..\src\alberopt.h:20:26: error: 'tipoElem' has not been declared
     void inserisciRadice(tipoElem);
                          ^~~~~~~~
..\src\alberopt.h:21:5: error: 'nodo' does not name a type
     nodo leggiRadice() const;
     ^~~~
..\src\alberopt.h:21:5: note: (perhaps 'typename Albero<T, nodoAlbero<T>*>::nodo' was intended)
..\src\alberopt.h:22:5: error: 'nodo' does not name a type
     nodo padre(nodo) const;
     ^~~~
..\src\alberopt.h:22:5: note: (perhaps 'typename Albero<T, nodoAlbero<T>*>::nodo' was intended)
..\src\alberopt.h:23:17: error: 'nodo' has not been declared
     bool foglia(nodo) const;
                 ^~~~
..\src\alberopt.h:24:5: error: 'nodo' does not name a type
     nodo primoFiglio(nodo) const;
     ^~~~
..\src\alberopt.h:24:5: note: (perhaps 'typename Albero<T, nodoAlbero<T>*>::nodo' was intended)
..\src\alberopt.h:25:25: error: 'nodo' has not been declared
     bool ultimoFratello(nodo) const;
                         ^~~~
..\src\alberopt.h:26:5: error: 'nodo' does not name a type
     nodo fratelloSuccessivo(nodo) const;
     ^~~~
..\src\alberopt.h:26:5: note: (perhaps 'typename Albero<T, nodoAlbero<T>*>::nodo' was intended)
..\src\alberopt.h:27:26: error: 'nodo' has not been declared
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                          ^~~~
..\src\alberopt.h:27:39: error: 'tipoElem' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                       ^~~~~~~~
..\src\alberopt.h:27:49: error: 'nodoT' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                 ^~~~~
..\src\alberopt.h:27:56: error: template argument 1 is invalid
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                        ^
..\src\alberopt.h:27:56: error: template argument 2 is invalid
..\src\alberopt.h:27:39: error: 'tipoElem' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                       ^~~~~~~~
..\src\alberopt.h:27:49: error: 'nodoT' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                 ^~~~~
..\src\alberopt.h:27:56: error: template argument 1 is invalid
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                        ^
..\src\alberopt.h:27:56: error: template argument 2 is invalid
..\src\alberopt.h:27:39: error: 'tipoElem' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                       ^~~~~~~~
..\src\alberopt.h:27:49: error: 'nodoT' was not declared in this scope
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                 ^~~~~
..\src\alberopt.h:27:56: error: template argument 1 is invalid
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                        ^
..\src\alberopt.h:27:56: error: template argument 2 is invalid
..\src\alberopt.h:27:32: error: 'Albero' is not a type
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                ^~~~~~
..\src\alberopt.h:27:38: error: expected ',' or '...' before '<' token
     void insFirstSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                      ^
..\src\alberopt.h:28:21: error: 'nodo' has not been declared
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                     ^~~~
..\src\alberopt.h:28:34: error: 'tipoElem' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                  ^~~~~~~~
..\src\alberopt.h:28:44: error: 'nodoT' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                            ^~~~~
..\src\alberopt.h:28:51: error: template argument 1 is invalid
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                   ^
..\src\alberopt.h:28:51: error: template argument 2 is invalid
..\src\alberopt.h:28:34: error: 'tipoElem' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                  ^~~~~~~~
..\src\alberopt.h:28:44: error: 'nodoT' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                            ^~~~~
..\src\alberopt.h:28:51: error: template argument 1 is invalid
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                   ^
..\src\alberopt.h:28:51: error: template argument 2 is invalid
..\src\alberopt.h:28:34: error: 'tipoElem' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                  ^~~~~~~~
..\src\alberopt.h:28:44: error: 'nodoT' was not declared in this scope
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                            ^~~~~
..\src\alberopt.h:28:51: error: template argument 1 is invalid
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                                   ^
..\src\alberopt.h:28:51: error: template argument 2 is invalid
..\src\alberopt.h:28:27: error: 'Albero' is not a type
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                           ^~~~~~
..\src\alberopt.h:28:33: error: expected ',' or '...' before '<' token
     void insSubTree(nodo, Albero<tipoElem, nodoT<T> *> &);
                                 ^
..\src\alberopt.h:29:26: error: 'nodo' has not been declared
     void cancSottoAlbero(nodo);
                          ^~~~
..\src\alberopt.h:30:21: error: 'nodo' has not been declared
     void scriviNodo(nodo, tipoElem);
                     ^~~~
..\src\alberopt.h:30:27: error: 'tipoElem' has not been declared
     void scriviNodo(nodo, tipoElem);
                           ^~~~~~~~
..\src\alberopt.h:31:5: error: 'tipoElem' does not name a type
     tipoElem leggiNodo(nodo) const;
     ^~~~~~~~
..\src\alberopt.h:31:5: note: (perhaps 'typename Albero<T, nodoAlbero<T>*>::tipoElem' was intended)
..\src\alberopt.h:33:31: error: 'nodo' has not been declared
     void inserisciPrimoFiglio(nodo, tipoElem);
                               ^~~~
..\src\alberopt.h:33:37: error: 'tipoElem' has not been declared
     void inserisciPrimoFiglio(nodo, tipoElem);
                                     ^~~~~~~~
..\src\alberopt.h:34:20: error: 'nodo' has not been declared
     void inserisci(nodo, tipoElem);
                    ^~~~
..\src\alberopt.h:34:26: error: 'tipoElem' has not been declared
     void inserisci(nodo, tipoElem);
                          ^~~~~~~~
..\src\alberopt.h:37:5: error: 'nodoT' does not name a type
     nodoT<T> *radice;
     ^~~~~
..\src\alberopt.h:39:16: error: 'nodo' has not been declared
     void copia(nodo, nodo);
                ^~~~
..\src\alberopt.h:39:22: error: 'nodo' has not been declared
     void copia(nodo, nodo);
                      ^~~~
..\src\alberopt.h:40:17: error: 'nodo' has not been declared
     void stampa(nodo) const;
                 ^~~~
..\src\alberopt.h: In destructor 'alberoPt<T>::~alberoPt()':
..\src\alberopt.h:45:36: error: 'radice' was not declared in this scope
     if (numNodi>0) cancSottoAlbero(radice);
                                    ^~~~~~
..\src\alberopt.h: In constructor 'alberoPt<T>::alberoPt()':
..\src\alberopt.h:51:5: error: 'radice' was not declared in this scope
     radice = nullptr;
     ^~~~~~
..\src\alberopt.h: In copy constructor 'alberoPt<T>::alberoPt(alberoPt<T>&)':
..\src\alberopt.h:56:5: error: 'radice' was not declared in this scope
     radice = nullptr;
     ^~~~~~
..\src\alberopt.h:57:18: error: 'nodoT' does not name a type
     radice = new nodoT<T>();
                  ^~~~~
..\src\alberopt.h:57:25: error: expected primary-expression before '>' token
     radice = new nodoT<T>();
                         ^
..\src\alberopt.h:57:27: error: expected primary-expression before ')' token
     radice = new nodoT<T>();
                           ^
In file included from ..\src\testTree.cpp:1:0:
..\src\alberopt.h: At global scope:
..\src\alberopt.h:68:25: error: variable or field 'copia' declared void
 void alberoPt<T>::copia(nodo n, nodo daCopiare) {
                         ^~~~
..\src\alberopt.h:68:25: error: 'nodo' was not declared in this scope
..\src\alberopt.h:68:33: error: 'nodo' was not declared in this scope
 void alberoPt<T>::copia(nodo n, nodo daCopiare) {
                                 ^~~~
..\src\alberopt.h:87:40: error: variable or field 'inserisciPrimoFiglio' declared void
 void alberoPt<T>::inserisciPrimoFiglio(nodo n, tipoElem e) {
                                        ^~~~
..\src\alberopt.h:87:40: error: 'nodo' was not declared in this scope
..\src\alberopt.h:87:48: error: 'tipoElem' was not declared in this scope
 void alberoPt<T>::inserisciPrimoFiglio(nodo n, tipoElem e) {
                                                ^~~~~~~~
..\src\alberopt.h:102:39: error: variable or field 'inserisci' declared void
 void alberoPt<T>::inserisci(alberoPt::nodo n , alberoPt::tipoElem e) {
                                       ^~~~
..\src\alberopt.h:102:44: error: expected ')' before 'n'
 void alberoPt<T>::inserisci(alberoPt::nodo n , alberoPt::tipoElem e) {
                                            ^
..\src\alberopt.h:102:48: error: 'template<class T> class alberoPt' used without template parameters
 void alberoPt<T>::inserisci(alberoPt::nodo n , alberoPt::tipoElem e) {
                                                ^~~~~~~~
..\src\alberopt.h: In member function 'bool alberoPt<T>::alberoVuoto() const':
..\src\alberopt.h:121:13: error: 'radice' was not declared in this scope
     return (radice == nullptr);
             ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:130:35: error: variable or field 'inserisciRadice' declared void
 void alberoPt<T>::inserisciRadice(tipoElem e) {
                                   ^~~~~~~~
..\src\alberopt.h:130:35: error: 'tipoElem' was not declared in this scope
..\src\alberopt.h:150:55: error: no 'typename alberoPt<T>::nodo alberoPt<T>::leggiRadice() const' member function declared in class 'alberoPt<T>'
 typename alberoPt<T>::nodo alberoPt<T>::leggiRadice() const {
                                                       ^~~~~
..\src\alberopt.h:162:47: error: 'typename alberoPt<T>::nodo alberoPt<T>::padre' is not a static data member of 'class alberoPt<T>'
 typename alberoPt<T>::nodo alberoPt<T>::padre(nodo n) const {
                                               ^~~~
..\src\alberopt.h:162:47: error: template definition of non-template 'typename alberoPt<T>::nodo alberoPt<T>::padre'
..\src\alberopt.h:162:47: error: 'nodo' was not declared in this scope
..\src\alberopt.h:177:26: error: 'bool alberoPt<T>::foglia' is not a static data member of 'class alberoPt<T>'
 bool alberoPt<T>::foglia(nodo n) const {
                          ^~~~
..\src\alberopt.h:177:26: error: template definition of non-template 'bool alberoPt<T>::foglia'
..\src\alberopt.h:177:26: error: 'nodo' was not declared in this scope
..\src\alberopt.h:189:53: error: 'typename alberoPt<T>::nodo alberoPt<T>::primoFiglio' is not a static data member of 'class alberoPt<T>'
 typename alberoPt<T>::nodo alberoPt<T>::primoFiglio(nodo n) const {
                                                     ^~~~
..\src\alberopt.h:189:53: error: template definition of non-template 'typename alberoPt<T>::nodo alberoPt<T>::primoFiglio'
..\src\alberopt.h:189:53: error: 'nodo' was not declared in this scope
..\src\alberopt.h:204:34: error: 'bool alberoPt<T>::ultimoFratello' is not a static data member of 'class alberoPt<T>'
 bool alberoPt<T>::ultimoFratello(nodo n) const {
                                  ^~~~
..\src\alberopt.h:204:34: error: template definition of non-template 'bool alberoPt<T>::ultimoFratello'
..\src\alberopt.h:204:34: error: 'nodo' was not declared in this scope
..\src\alberopt.h:216:60: error: 'typename alberoPt<T>::nodo alberoPt<T>::fratelloSuccessivo' is not a static data member of 'class alberoPt<T>'
 typename alberoPt<T>::nodo alberoPt<T>::fratelloSuccessivo(nodo n) const {
                                                            ^~~~
..\src\alberopt.h:216:60: error: template definition of non-template 'typename alberoPt<T>::nodo alberoPt<T>::fratelloSuccessivo'
..\src\alberopt.h:216:60: error: 'nodo' was not declared in this scope
..\src\alberopt.h:231:35: error: variable or field 'insFirstSubTree' declared void
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                   ^~~~
..\src\alberopt.h:231:35: error: 'nodo' was not declared in this scope
..\src\alberopt.h:231:50: error: 'tipoElem' was not declared in this scope
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                  ^~~~~~~~
..\src\alberopt.h:231:60: error: 'nodoT' was not declared in this scope
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                            ^~~~~
..\src\alberopt.h:231:67: error: template argument 1 is invalid
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                                   ^
..\src\alberopt.h:231:67: error: template argument 2 is invalid
..\src\alberopt.h:231:70: error: expected primary-expression before '>' token
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                                      ^
..\src\alberopt.h:231:73: error: 'a' was not declared in this scope
 void alberoPt<T>::insFirstSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                                         ^
..\src\alberopt.h:252:30: error: variable or field 'insSubTree' declared void
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                              ^~~~
..\src\alberopt.h:252:30: error: 'nodo' was not declared in this scope
..\src\alberopt.h:252:45: error: 'tipoElem' was not declared in this scope
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                             ^~~~~~~~
..\src\alberopt.h:252:55: error: 'nodoT' was not declared in this scope
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                       ^~~~~
..\src\alberopt.h:252:62: error: template argument 1 is invalid
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                              ^
..\src\alberopt.h:252:62: error: template argument 2 is invalid
..\src\alberopt.h:252:65: error: expected primary-expression before '>' token
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                                 ^
..\src\alberopt.h:252:68: error: 'a' was not declared in this scope
 void alberoPt<T>::insSubTree(nodo n, Albero<tipoElem, nodoT<T> *> &a) {
                                                                    ^
..\src\alberopt.h:275:35: error: variable or field 'cancSottoAlbero' declared void
 void alberoPt<T>::cancSottoAlbero(nodo n) {
                                   ^~~~
..\src\alberopt.h:275:35: error: 'nodo' was not declared in this scope
..\src\alberopt.h:301:30: error: variable or field 'scriviNodo' declared void
 void alberoPt<T>::scriviNodo(nodo n, tipoElem e) {
                              ^~~~
..\src\alberopt.h:301:30: error: 'nodo' was not declared in this scope
..\src\alberopt.h:301:38: error: 'tipoElem' was not declared in this scope
 void alberoPt<T>::scriviNodo(nodo n, tipoElem e) {
                                      ^~~~~~~~
..\src\alberopt.h:311:55: error: 'typename alberoPt<T>::tipoElem alberoPt<T>::leggiNodo' is not a static data member of 'class alberoPt<T>'
 typename alberoPt<T>::tipoElem alberoPt<T>::leggiNodo(nodo n) const {
                                                       ^~~~
..\src\alberopt.h:311:55: error: template definition of non-template 'typename alberoPt<T>::tipoElem alberoPt<T>::leggiNodo'
..\src\alberopt.h:311:55: error: 'nodo' was not declared in this scope
..\src\alberopt.h: In member function 'void alberoPt<T>::stampaAlbero() const':
..\src\alberopt.h:320:9: error: 'radice' was not declared in this scope
     if (radice != nullptr) {
         ^~~~~~
..\src\alberopt.h: At global scope:
..\src\alberopt.h:331:26: error: variable or field 'stampa' declared void
 void alberoPt<T>::stampa(nodo n) const {
                          ^~~~
..\src\alberopt.h:331:26: error: 'nodo' was not declared in this scope
..\src\testTree.cpp: In function 'int main()':
..\src\testTree.cpp:4:5: error: 'AlberoPt' was not declared in this scope
     AlberoPt<int> albero;
     ^~~~~~~~
..\src\testTree.cpp:4:14: error: expected primary-expression before 'int'
     AlberoPt<int> albero;
              ^~~
..\src\testTree.cpp:7:5: error: 'albero' was not declared in this scope
     albero.inserisciRadice(1);
     ^~~~~~
..\src\testTree.cpp:14:56: error: expected primary-expression before 'int'
     albero.inserisciPrimoSottoAlbero(figlio1, AlberoPt<int>());
                                                        ^~~
00:06:28 **** Incremental Build of configuration Debug for project 7 alb_nari ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberolistadin.o" "..\\src\\testalberolistadin.cpp" 
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'class alberoListaDin<int>':
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:21:5: error: 'alberoListaDin<T>::~alberoListaDin() [with T = int]' marked 'override', but does not override
     ~alberoListaDin() override {
     ^
..\src\alberoListaDin.h:70:39: error: 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]' marked 'override', but does not override
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:13:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:13:7: note:   because the following virtual functions are pure within 'alberoListaDin<int>':
 class alberoListaDin : public alberoAstratto<T, alberoListaDin<T>> {
       ^~~~~~~~~~~~~~
In file included from ..\src\alberoListaDin.h:5:0,
                 from ..\src\testalberolistadin.cpp:1:
..\src\alberoAstratto.h:10:15: note: 	void alberoAstratto<T, P>::creaAlbero() [with T = int; P = alberoListaDin<int>]
  virtual void creaAlbero() =0;
               ^~~~~~~~~~
..\src\alberoAstratto.h:11:15: note: 	bool alberoAstratto<T, P>::alberoVuoto() const [with T = int; P = alberoListaDin<int>]
  virtual bool alberoVuoto() const =0;
               ^~~~~~~~~~~
..\src\alberoAstratto.h:12:15: note: 	void alberoAstratto<T, P>::insRadice(alberoAstratto<T, P>::tipoelem) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::tipoelem = int]
  virtual void insRadice(tipoelem) =0;
               ^~~~~~~~~
..\src\alberoAstratto.h:13:20: note: 	alberoAstratto<T, P>::posizione alberoAstratto<T, P>::radiceAlbero() [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual posizione radiceAlbero() =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:19:15: note: 	void alberoAstratto<T, P>::cancSottoAlbero(alberoAstratto<T, P>::posizione&) [with T = int; P = alberoListaDin<int>; alberoAstratto<T, P>::posizione = alberoListaDin<int>]
  virtual void cancSottoAlbero(posizione&) =0;
               ^~~~~~~~~~~~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione padre(posizione) const =0;
                    ^~~~~
..\src\alberoAstratto.h:14:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:15:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool foglia(posizione) const =0;
               ^~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione primoFiglio(posizione) const =0;
                    ^~~~~~~~~~~
..\src\alberoAstratto.h:16:20: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoAstratto.h:17:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual bool ultimoFratello(posizione) const =0;
               ^~~~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract return type 'alberoListaDin<int>'
  virtual posizione succFratello(posizione) const =0;
                    ^~~~~~~~~~~~
..\src\alberoAstratto.h:18:20: error: invalid abstract parameter type 'alberoListaDin<int>'
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:70:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:75:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:83:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::foglia(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:88:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:96:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 bool alberoListaDin<T>::ultimoFratello(posizione p) const {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract return type 'alberoListaDin<int>'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:104:39: error: invalid abstract parameter type 'alberoListaDin<int>'
..\src\alberoListaDin.h:119:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insPrimoSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:131:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::insSottoAlbero(posizione p, const alberoListaDin<T>& sottoAlbero) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\testalberolistadin.cpp: In function 'int main()':
..\src\testalberolistadin.cpp:5:25: error: cannot declare variable 'albero' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> albero;
                         ^~~~~~
..\src\testalberolistadin.cpp:11:25: error: cannot declare variable 'sottoAlbero1' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                         ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:39: error: cannot declare variable 'sottoAlbero2' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                       ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:11:53: error: cannot declare variable 'sottoAlbero3' to be of abstract type 'alberoListaDin<int>'
     alberoListaDin<int> sottoAlbero1, sottoAlbero2, sottoAlbero3;
                                                     ^~~~~~~~~~~~
..\src\testalberolistadin.cpp:16:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insPrimoSottoAlbero(albero.radiceAlbero(), sottoAlbero1);
                                                    ^
..\src\testalberolistadin.cpp:17:47: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.radiceAlbero(), sottoAlbero2);
                                               ^
..\src\testalberolistadin.cpp:18:66: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     albero.insSottoAlbero(albero.primoFiglio(albero.radiceAlbero()), sottoAlbero3);
                                                                  ^
..\src\testalberolistadin.cpp:22:52: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     std::cout << "Radice: " << albero.radiceAlbero().radice->getElemento() << std::endl;
                                                    ^
..\src\testalberolistadin.cpp:24:55: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     auto pos = albero.primoFiglio(albero.radiceAlbero());
                                                       ^
In file included from ..\src\listaPuntatore.h:6:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaLineare.h: In instantiation of 'class listaLineare<alberoListaDin<int>, nodo<alberoListaDin<int> >*>':
..\src\listaPuntatore.h:11:7:   required from 'class listaPuntatore<alberoListaDin<int> >'
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaLineare.h:17:19: error: invalid abstract return type 'alberoListaDin<int>'
  virtual tipoelem leggiLista (posizione) const=0;
                   ^~~~~~~~~~
..\src\listaLineare.h:18:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void scriviLista (tipoelem, posizione)=0; // scrive un elemento nella posizione scelta
               ^~~~~~~~~~~
..\src\listaLineare.h:23:15: error: invalid abstract parameter type 'alberoListaDin<int>'
  virtual void insLista (tipoelem, posizione) =0; // inserisce un elemento nella lista
               ^~~~~~~~
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h: In instantiation of 'class listaPuntatore<alberoListaDin<int> >':
..\src\nodoAlbero.h:28:20:   required from 'class nodoAlbero<int, alberoListaDin<int> >'
..\src\alberoListaDin.h:24:13:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\listaPuntatore.h:116:38: error: invalid abstract return type 'alberoListaDin<int>'
 typename listaPuntatore<T>::tipoelem listaPuntatore<T>::leggiLista (typename listaPuntatore<T>::posizione p) const{
                                      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:127:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::scriviLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:168:6: error: invalid abstract parameter type 'alberoListaDin<int>'
 void listaPuntatore<T>::insLista (typename listaPuntatore<T>::tipoelem e, typename listaPuntatore<T>::posizione p){
      ^~~~~~~~~~~~~~~~~
..\src\listaPuntatore.h:214:39: error: invalid abstract parameter type 'alberoListaDin<int>'
 typename listaPuntatore<T>::posizione listaPuntatore<T>::cercaElemento(typename listaPuntatore<T>::tipoelem e) const{
                                       ^~~~~~~~~~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:16:52:   required from here
..\src\alberoListaDin.h:70:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::radiceAlbero() const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:71:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione(radice);
            ^~~~~~~~~~~~~~~~~
In file included from ..\src\listaPuntatore.h:7:0,
                 from ..\src\nodoAlbero.h:4,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\nodo.h: In instantiation of 'class nodo<alberoListaDin<int> >':
..\src\alberoListaDin.h:156:28:   required from 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]'
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\nodo.h:11:2: error: invalid abstract parameter type 'alberoListaDin<int>'
  nodo (const tipoelem e) { elemento = e; };
  ^~~~
..\src\nodo.h:14:7: error: invalid abstract parameter type 'alberoListaDin<int>'
  void setElemento (tipoelem e) { elemento = e; };
       ^~~~~~~~~~~
..\src\nodo.h:15:11: error: invalid abstract return type 'alberoListaDin<int>'
  tipoelem getElemento () const { return elemento; };
           ^~~~~~~~~~~
..\src\nodo.h:21:11: error: cannot declare field 'nodo<alberoListaDin<int> >::elemento' to be of abstract type 'alberoListaDin<int>'
  tipoelem elemento;
           ^~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h: In instantiation of 'void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]':
..\src\alberoListaDin.h:23:28:   required from 'alberoListaDin<T>::~alberoListaDin() [with T = int]'
..\src\testalberolistadin.cpp:5:25:   required from here
..\src\alberoListaDin.h:156:28: error: no matching function for call to 'alberoListaDin<int>::cancSottoAlbero(listaPuntatore<alberoListaDin<int> >::posizione)'
             cancSottoAlbero(figli.primoLista());
             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(alberoListaDin<T>::posizione) [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]
 void alberoListaDin<T>::cancSottoAlbero(posizione p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:143:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'alberoListaDin<int>::posizione {aka alberoListaDin<int>}'
..\src\alberoListaDin.h:152:6: note: candidate: void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T> >*) [with T = int]
 void alberoListaDin<T>::cancSottoAlbero(nodoAlbero<T, alberoListaDin<T>>* p) {
      ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:152:6: note:   no known conversion for argument 1 from 'listaPuntatore<alberoListaDin<int> >::posizione {aka nodo<alberoListaDin<int> >*}' to 'nodoAlbero<int, alberoListaDin<int> >*'
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:75:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::padre(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::padre(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:77:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:79:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::foglia(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:84:56: error: 'int listaPuntatore<alberoListaDin<int> >::lunghezza' is private within this context
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                         
In file included from ..\src\nodoAlbero.h:4:0,
                 from ..\src\alberoListaDin.h:6,
                 from ..\src\testalberolistadin.cpp:1:
..\src\listaPuntatore.h:69:9: note: declared private here
     int lunghezza;
         ^~~~~~~~~
In file included from ..\src\testalberolistadin.cpp:1:0:
..\src\alberoListaDin.h:84:68: error: expression cannot be used as a function
     return p.radice != nullptr && p.radice->getFigli().lunghezza() == 0;
                                                                     
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:88:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::primoFiglio(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:89:39: error: cannot allocate an object of abstract type 'alberoListaDin<int>'
     if (p.radice != nullptr && !foglia(p)) {
                                 ~~~~~~^~~
..\src\alberoListaDin.h:90:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getFigli().primoLista());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:92:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
..\src\alberoListaDin.h: In instantiation of 'bool alberoListaDin<T>::ultimoFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:98:50: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return p.radice == p.radice->getPadre()->getFigli().ultimoLista();
                                                   
..\src\alberoListaDin.h: In instantiation of 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]':
..\src\testalberolistadin.cpp:31:1:   required from here
..\src\alberoListaDin.h:104:39: error: invalid abstract return type for member function 'alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(alberoListaDin<T>::posizione) const [with T = int; alberoListaDin<T>::posizione = alberoListaDin<int>]'
 typename alberoListaDin<T>::posizione alberoListaDin<T>::succFratello(posizione p) const {
                                       ^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:48: error: 'class alberoListaDin<int>' has no member named 'getFigli'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                 
..\src\alberoListaDin.h:106:79: error: 'class nodoAlbero<int, alberoListaDin<int> >' has no member named 'getPosizioneLista'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:106:16: error: invalid cast to abstract class type 'alberoListaDin<int>'
         return posizione(p.radice->getPadre()->getFigli().succLista(p.radice->getPosizioneLista()));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
..\src\alberoListaDin.h:108:12: error: invalid cast to abstract class type 'alberoListaDin<int>'
     return posizione();
            ^~~~~~~~~~~
00:06:28 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o tempalbpt.exe "src\\testTree.o" 
c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'
collect2.exe: error: ld returned 1 exit status
00:07:58 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o tempalbpt.exe "src\\testTree.o" 
Info: Nothing to build for tempalbpt
00:09:11 **** Incremental Build of configuration Debug for project tempalbpt ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o tempalbpt.exe "src\\testTree.o" 
Info: Nothing to build for tempalbpt
10:00:59 **** Rebuild of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
..\src\testalberobinarray.cpp: In function 'int main()':
..\src\testalberobinarray.cpp:21:69: error: no matching function for call to 'contaFoglieAlLivello(alberoBinArray<int>&, int&)'
     int numeroFoglie = contaFoglieAlLivello(albero, livelloDaTestare);
                                                                     ^
In file included from ..\src\testalberobinarray.cpp:2:0:
..\src\alberoBinArray.h:467:5: note: candidate: template<class T> int contaFoglieAlLivello(const alberoBinArray<T>&, int, typename alberoBinArray<T>::posizione)
 int contaFoglieAlLivello(const alberoBinArray<T>& albero, int livello, typename alberoBinArray<T>::posizione p) {
     ^~~~~~~~~~~~~~~~~~~~
..\src\alberoBinArray.h:467:5: note:   template argument deduction/substitution failed:
..\src\testalberobinarray.cpp:21:69: note:   candidate expects 3 arguments, 2 provided
     int numeroFoglie = contaFoglieAlLivello(albero, livelloDaTestare);
                                                                     ^
10:02:07 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:2:0:
..\src\alberoBinArray.h: In instantiation of 'int contaFoglieAlLivello(const alberoBinArray<T>&, int, typename alberoBinArray<T>::posizione) [with T = int; typename alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:21:89:   required from here
..\src\alberoBinArray.h:468:21: error: 'const int alberoBinArray<int>::NIL' is private within this context
     if (p == albero.NIL || livello < 0) {
              ~~~~~~~^~~
In file included from ..\src\testalberobinarray.cpp:2:0:
..\src\alberoBinArray.h:89:19: note: declared private here
  static const int NIL = -1;
                   ^~~
10:03:02 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:2:0:
..\src\alberoBinArray.h: In instantiation of 'int contaFoglieAlLivello(const alberoBinArray<T>&, int, typename alberoBinArray<T>::posizione) [with T = int; typename alberoBinArray<T>::posizione = int]':
..\src\testalberobinarray.cpp:21:89:   required from here
..\src\alberoBinArray.h:467:21: error: 'const class alberoBinArray<int>' has no member named 'NIL'
     if (p == albero.NIL || livello < 0) {
              ~~~~~~~^~~
10:03:23 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:06:47 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
src\testalberobinarray.o: In function `ZN14alberoBinArrayIiE14aggiornaLiberoEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Ferrara_Marco\Debug/../src/alberoBinArray.h:401: undefined reference to `alberoBinArray<int>::cambiaDimensioneArray(alberoBinArray<int>::cella*&, int, int)'
collect2.exe: error: ld returned 1 exit status
10:06:59 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
src\testalberobinarray.o: In function `ZN14alberoBinArrayIiE12insBinRadiceEi':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Ferrara_Marco\Debug/../src/alberoBinArray.h:281: undefined reference to `alberoBinArray<int>::aggiornaLibero()'
src\testalberobinarray.o: In function `ZN14alberoBinArrayIiE17insFiglioSinistroEii':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Ferrara_Marco\Debug/../src/alberoBinArray.h:300: undefined reference to `alberoBinArray<int>::aggiornaLibero()'
src\testalberobinarray.o: In function `ZN14alberoBinArrayIiE15insFiglioDestroEii':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Ferrara_Marco\Debug/../src/alberoBinArray.h:319: undefined reference to `alberoBinArray<int>::aggiornaLibero()'
collect2.exe: error: ld returned 1 exit status
10:07:25 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
src\testalberobinarray.o: In function `ZN14alberoBinArrayIiE14aggiornaLiberoEv':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati + Lab\Ferrara_Marco\Debug/../src/alberoBinArray.h:380: undefined reference to `alberoBinArray<int>::cambiaDimensioneArray(alberoBinArray<int>::cella*&, int, int)'
collect2.exe: error: ld returned 1 exit status
10:07:41 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:07:52 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
10:08:00 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
10:09:13 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:17:03 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:1:0:
..\src\alberoBinArray.h:51:9: error: 'ostream' does not name a type
  friend ostream& operator<<(ostream& os, const  alberoBinArray<T>& a){
         ^~~~~~~
..\src\testalberobinarray.cpp: In function 'int main()':
..\src\testalberobinarray.cpp:26:5: error: 'cout' was not declared in this scope
     cout << "Albero Binario:" << endl;
     ^~~~
..\src\testalberobinarray.cpp:26:34: error: 'endl' was not declared in this scope
     cout << "Albero Binario:" << endl;
                                  ^~~~
10:18:03 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:1:0:
..\src\alberoBinArray.h:51:9: error: 'ostream' does not name a type
  friend ostream& operator<<(ostream& os, const  alberoBinArray<T>& a){
         ^~~~~~~
..\src\testalberobinarray.cpp: In function 'int main()':
..\src\testalberobinarray.cpp:29:2: error: 'cout' was not declared in this scope
  cout << "Albero Binario:" << endl;
  ^~~~
..\src\testalberobinarray.cpp:29:31: error: 'endl' was not declared in this scope
  cout << "Albero Binario:" << endl;
                               ^~~~
..\src\testalberobinarray.cpp:37:2: error: 'cout' is not a member of 'std'
  std::cout << "Numero di foglie al livello " << livelloDaTestare << ": " << numeroFoglie << std::endl;
  ^~~
..\src\testalberobinarray.cpp:37:93: error: 'endl' is not a member of 'std'
  std::cout << "Numero di foglie al livello " << livelloDaTestare << ": " << numeroFoglie << std::endl;
                                                                                             ^~~
10:19:04 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
10:20:19 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:24:30 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
10:30:37 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:31:26 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:33:38 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:35:27 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
10:35:40 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
10:36:02 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
10:36:10 **** Incremental Build of configuration Debug for project Ferrara_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrara_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrara_Marco
Info: Nothing to build for Ferrara_Marco
10:06:33 **** Incremental Build of configuration Debug for project 5 alb_bin ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o "5 alb_bin.exe" "src\\testalberobinarray.o" 
10:06:34 **** Rebuild of configuration Debug for project Ferrarra_Marco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o Ferrarra_Marco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for Ferrarra_Marco
10:17:00 **** Rebuild of configuration Debug for project DiChioMariaTeresa ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o DiChioMariaTeresa.exe "src\\testalberobinarray.o" 
Info: Nothing to build for DiChioMariaTeresa
10:22:50 **** Rebuild of configuration Debug for project FerraraMarco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o FerraraMarco.exe "src\\testalberobinarray.o" 
10:23:19 **** Incremental Build of configuration Debug for project FerraraMarco ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o FerraraMarco.exe "src\\testalberobinarray.o" 
Info: Nothing to build for FerraraMarco
Info: Nothing to build for FerraraMarco
10:42:49 **** Rebuild of configuration Debug for project DiChioMariaTeresa ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
In file included from ..\src\testalberobinarray.cpp:2:0:
..\src\alberobinarray.h:99:6: error: redefinition of 'bool alberoBinArray<T>::ordered() const'
 bool alberoBinArray<T>::ordered() const {
      ^~~~~~~~~~~~~~~~~
..\src\alberobinarray.h:94:6: note: 'bool alberoBinArray<T>::ordered() const' previously declared here
 bool alberoBinArray<T>::ordered() const {
      ^~~~~~~~~~~~~~~~~
10:44:53 **** Incremental Build of configuration Debug for project DiChioMariaTeresa ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testalberobinarray.o" "..\\src\\testalberobinarray.cpp" 
g++ -o DiChioMariaTeresa.exe "src\\testalberobinarray.o" 
Info: Nothing to build for DiChioMariaTeresa
16:55:26 **** Rebuild of configuration Debug for project tem ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\tem.o" "..\\src\\tem.cpp" 
g++ -o tem.exe "src\\tem.o" 
Info: Nothing to build for tem
17:06:30 **** Rebuild of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\tmp.o" "..\\src\\tmp.cpp" 
g++ -o tmp.exe "src\\tmp.o" 
Info: Nothing to build for tmp
17:06:52 **** Incremental Build of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\tmp.o" "..\\src\\tmp.cpp" 
g++ -o tmp.exe "src\\tmp.o" 
Info: Nothing to build for tmp
Info: Nothing to build for tmp
17:09:33 **** Incremental Build of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\tmp.o" "..\\src\\tmp.cpp" 
g++ -o tmp.exe "src\\tmp.o" 
Info: Nothing to build for tmp
10:09:07 **** Rebuild of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o "Alberi nari funzia.exe" "src\\testTree.o" 
Info: Nothing to build for Alberi nari funzia
10:12:07 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o "Alberi nari funzia.exe" "src\\testTree.o" 
Info: Nothing to build for Alberi nari funzia
10:14:11 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o "Alberi nari funzia.exe" "src\\testTree.o" 
Info: Nothing to build for Alberi nari funzia
10:17:17 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
g++ -o "Alberi nari funzia.exe" "src\\testTree.o" 
src\testTree.o: In function `main':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati\Alberi nari funzia\Debug/../src/testTree.cpp:52: undefined reference to `treePt<int>::printTree() const'
collect2.exe: error: ld returned 1 exit status
10:17:22 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -o "Alberi nari funzia.exe" "src\\testTree.o" 
src\testTree.o: In function `main':
C:\Users\marco\Desktop\Cartelle Desktop\Universita\Materie\2 Anno\1 Semestre\ASD\Strutture Dati\Alberi nari funzia\Debug/../src/testTree.cpp:52: undefined reference to `treePt<int>::printTree() const'
collect2.exe: error: ld returned 1 exit status
10:17:56 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\treePt.h:257:6: error: redeclaration of 'void treePt<T>::printNTree(treeNode<T>*, std::vector<bool>&, int, bool)' may not have default arguments [-fpermissive]
 void treePt<T>::printNTree(treeNode<T>* x, vector<bool>& flag, int depth = 0, bool isLast = false)
      ^~~~~~~~~
10:18:21 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\treePt.h:257:6: error: redeclaration of 'void treePt<T>::printNTree(treeNode<T>*, std::vector<bool>&, int, bool)' may not have default arguments [-fpermissive]
 void treePt<T>::printNTree(treeNode<T>* x, vector<bool>& flag, int depth = 0, bool isLast = false)
      ^~~~~~~~~
10:29:18 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\treePt.h:257:6: error: redeclaration of 'void treePt<T>::printNTree(treeNode<T>*, std::vector<bool>&, int, bool)' may not have default arguments [-fpermissive]
 void treePt<T>::printNTree(treeNode<T>* x, vector<bool>& flag, int depth = 0, bool isLast = false)
      ^~~~~~~~~
10:29:19 **** Rebuild of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\N_tree.o" "..\\src\\N_tree.cpp" 
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h:113:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:114:53: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::inner(nodo n, const T parent_value) {
                                                     ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:130:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:131:44: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificare_albero(nodo n) {
                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:145:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:146:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificareEtichetta(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:152:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:153:49: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::calcolaresumsottoalbero(nodo n) {
                                                 ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:170:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:171:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::previsita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:185:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:186:25: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr() {
                         ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:191:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:192:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profonditaAlbero() {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:200:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:201:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profondita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:225:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:226:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr(const AlberoPtr<T>& a) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:235:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:236:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::copiaNodo(nodo n, nodo daCopiare) {
                                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:248:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:249:26: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::~AlberoPtr() {
                          ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:258:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:259:34: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::alberoVuoto() const{
                                  ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:263:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:264:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::radice() const{
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:271:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:272:57: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::padre(nodo n) const{
                                                         ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:283:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:284:35: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::foglia(nodo n) const{
                                   ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:293:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:294:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::primoFiglio(nodo n) const{
                                                               ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:303:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:304:43: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::ultimoFratello(nodo n) const{
                                           ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:310:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:311:70: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::fratelloSuccessivo(nodo n) const{
                                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:320:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:321:48: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::inserisciRadice(tipoElem val) {
                                                ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:334:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:335:55: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoFiglio(nodo n, tipoElem val) {
                                                       ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:350:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:351:62: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insFratelloSuccessivo(nodo n, tipoElem val) {
                                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:368:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:369:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                               ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:386:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:387:59: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>:: insSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                           ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:406:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:407:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::cancellaSottoAlbero(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:430:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:431:51: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::scriviNodo(nodo n, tipoElem val) {
                                                   ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:440:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:441:65: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::tipoElem AlberoPtr<T>::leggiNodo(nodo n) const {
                                                                 ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:450:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:451:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator==(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:461:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:462:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator!=(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:466:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:467:60: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T> &AlberoPtr<T>::operator=(const AlberoPtr<T> &a) {
                                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:483:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:484:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaSottoAlbero(nodo n) const {
                                              ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:488:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:489:71: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaRicorsiva(Nodo<T> *nodo, std::string spazio) const {
                                                                       ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:511:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:512:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::confrontaNodi(nodo n1, nodo n2) const {
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.cpp:27:1: error: expected '}' at end of input
 }
 ^
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h: In member function 'int AlberoPtr<T>::ottieniNumeroNodi() const':
..\src\N_tree.h:86:41: error: 'numeroNodi' was not declared in this scope
  int ottieniNumeroNodi() const { return numeroNodi; }
                                         ^~~~~~~~~~
..\src\N_tree.h: In member function 'int AlberoPtr<T>::inner(AlberoPtr<T>::nodo, T)':
..\src\N_tree.h:106:1: error: expected primary-expression before 'private'
 private:
 ^~~~~~~
..\src\N_tree.h:111:1: warning: no return statement in function returning non-void [-Wreturn-type]
 };
 ^
..\src\N_tree.cpp: At global scope:
..\src\N_tree.cpp:27:1: error: expected ';' at end of input
 }
 ^
10:30:07 **** Incremental Build of configuration Debug for project Alberi nari funzia ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\testTree.o" "..\\src\\testTree.cpp" 
In file included from ..\src\testTree.cpp:1:0:
..\src\treePt.h:257:6: error: redeclaration of 'void treePt<T>::printNTree(treeNode<T>*, std::vector<bool>&, int, bool)' may not have default arguments [-fpermissive]
 void treePt<T>::printNTree(treeNode<T>* x, vector<bool>& flag, int depth = 0, bool isLast = false)
      ^~~~~~~~~
10:30:08 **** Incremental Build of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\N_tree.o" "..\\src\\N_tree.cpp" 
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h:113:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:114:53: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::inner(nodo n, const T parent_value) {
                                                     ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:130:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:131:44: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificare_albero(nodo n) {
                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:145:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:146:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificareEtichetta(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:152:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:153:49: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::calcolaresumsottoalbero(nodo n) {
                                                 ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:170:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:171:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::previsita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:185:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:186:25: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr() {
                         ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:191:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:192:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profonditaAlbero() {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:200:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:201:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profondita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:225:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:226:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr(const AlberoPtr<T>& a) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:235:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:236:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::copiaNodo(nodo n, nodo daCopiare) {
                                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:248:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:249:26: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::~AlberoPtr() {
                          ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:258:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:259:34: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::alberoVuoto() const{
                                  ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:263:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:264:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::radice() const{
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:271:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:272:57: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::padre(nodo n) const{
                                                         ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:283:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:284:35: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::foglia(nodo n) const{
                                   ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:293:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:294:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::primoFiglio(nodo n) const{
                                                               ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:303:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:304:43: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::ultimoFratello(nodo n) const{
                                           ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:310:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:311:70: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::fratelloSuccessivo(nodo n) const{
                                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:320:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:321:48: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::inserisciRadice(tipoElem val) {
                                                ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:334:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:335:55: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoFiglio(nodo n, tipoElem val) {
                                                       ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:350:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:351:62: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insFratelloSuccessivo(nodo n, tipoElem val) {
                                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:368:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:369:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                               ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:386:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:387:59: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>:: insSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                           ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:406:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:407:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::cancellaSottoAlbero(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:430:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:431:51: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::scriviNodo(nodo n, tipoElem val) {
                                                   ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:440:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:441:65: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::tipoElem AlberoPtr<T>::leggiNodo(nodo n) const {
                                                                 ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:450:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:451:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator==(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:461:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:462:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator!=(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:466:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:467:60: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T> &AlberoPtr<T>::operator=(const AlberoPtr<T> &a) {
                                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:483:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:484:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaSottoAlbero(nodo n) const {
                                              ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:488:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:489:71: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaRicorsiva(Nodo<T> *nodo, std::string spazio) const {
                                                                       ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:511:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:512:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::confrontaNodi(nodo n1, nodo n2) const {
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.cpp:27:1: error: expected '}' at end of input
 }
 ^
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h: In member function 'int AlberoPtr<T>::ottieniNumeroNodi() const':
..\src\N_tree.h:86:41: error: 'numeroNodi' was not declared in this scope
  int ottieniNumeroNodi() const { return numeroNodi; }
                                         ^~~~~~~~~~
..\src\N_tree.h: In member function 'int AlberoPtr<T>::inner(AlberoPtr<T>::nodo, T)':
..\src\N_tree.h:106:1: error: expected primary-expression before 'private'
 private:
 ^~~~~~~
..\src\N_tree.h:111:1: warning: no return statement in function returning non-void [-Wreturn-type]
 };
 ^
..\src\N_tree.cpp: At global scope:
..\src\N_tree.cpp:27:1: error: expected ';' at end of input
 }
 ^
10:30:15 **** Incremental Build of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\N_tree.o" "..\\src\\N_tree.cpp" 
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h:113:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:114:53: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::inner(nodo n, const T parent_value) {
                                                     ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:130:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:131:44: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificare_albero(nodo n) {
                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:145:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:146:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::modificareEtichetta(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:152:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:153:49: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::calcolaresumsottoalbero(nodo n) {
                                                 ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:170:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:171:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::previsita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:185:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:186:25: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr() {
                         ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:191:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:192:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profonditaAlbero() {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:200:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:201:36: error: invalid use of incomplete type 'class AlberoPtr<T>'
 int AlberoPtr<T>::profondita(nodo n) {
                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:225:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:226:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::AlberoPtr(const AlberoPtr<T>& a) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:235:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:236:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::copiaNodo(nodo n, nodo daCopiare) {
                                                    ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:248:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:249:26: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T>::~AlberoPtr() {
                          ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:258:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:259:34: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::alberoVuoto() const{
                                  ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:263:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:264:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::radice() const{
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:271:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:272:57: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::padre(nodo n) const{
                                                         ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:283:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:284:35: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::foglia(nodo n) const{
                                   ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:293:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:294:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::primoFiglio(nodo n) const{
                                                               ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:303:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:304:43: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::ultimoFratello(nodo n) const{
                                           ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:310:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:311:70: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::nodo AlberoPtr<T>::fratelloSuccessivo(nodo n) const{
                                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:320:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:321:48: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::inserisciRadice(tipoElem val) {
                                                ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:334:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:335:55: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoFiglio(nodo n, tipoElem val) {
                                                       ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:350:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:351:62: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insFratelloSuccessivo(nodo n, tipoElem val) {
                                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:368:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:369:63: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::insPrimoSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                               ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:386:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:387:59: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>:: insSottoAlbero(nodo n, AlberoPtr<T> &a) {
                                                           ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:406:11: error: declaration of template parameter 'T' shadows template parameter
 template <class T>
           ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:407:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::cancellaSottoAlbero(nodo n) {
                                              ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:430:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:431:51: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::scriviNodo(nodo n, tipoElem val) {
                                                   ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:440:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:441:65: error: invalid use of incomplete type 'class AlberoPtr<T>'
 typename AlberoPtr<T>::tipoElem AlberoPtr<T>::leggiNodo(nodo n) const {
                                                                 ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:450:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:451:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator==(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:461:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:462:54: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::operator!=(const AlberoPtr<T> &a) const {
                                                      ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:466:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:467:60: error: invalid use of incomplete type 'class AlberoPtr<T>'
 AlberoPtr<T> &AlberoPtr<T>::operator=(const AlberoPtr<T> &a) {
                                                            ^
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:483:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:484:46: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaSottoAlbero(nodo n) const {
                                              ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:488:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:489:71: error: invalid use of incomplete type 'class AlberoPtr<T>'
 void AlberoPtr<T>::stampaRicorsiva(Nodo<T> *nodo, std::string spazio) const {
                                                                       ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.h:511:10: error: declaration of template parameter 'T' shadows template parameter
 template<class T>
          ^~~~~
..\src\N_tree.h:63:10: note: template parameter 'T' declared here
 template<class T>
          ^~~~~
..\src\N_tree.h:512:52: error: invalid use of incomplete type 'class AlberoPtr<T>'
 bool AlberoPtr<T>::confrontaNodi(nodo n1, nodo n2) const {
                                                    ^~~~~
..\src\N_tree.h:64:7: note: declaration of 'class AlberoPtr<T>'
 class AlberoPtr : public Albero<T, Nodo<T> *> {
       ^~~~~~~~~
..\src\N_tree.cpp:27:1: error: expected '}' at end of input
 }
 ^
In file included from ..\src\N_tree.cpp:3:0:
..\src\N_tree.h: In member function 'int AlberoPtr<T>::ottieniNumeroNodi() const':
..\src\N_tree.h:86:41: error: 'numeroNodi' was not declared in this scope
  int ottieniNumeroNodi() const { return numeroNodi; }
                                         ^~~~~~~~~~
..\src\N_tree.h: In member function 'int AlberoPtr<T>::inner(AlberoPtr<T>::nodo, T)':
..\src\N_tree.h:106:1: error: expected primary-expression before 'private'
 private:
 ^~~~~~~
..\src\N_tree.h:111:1: warning: no return statement in function returning non-void [-Wreturn-type]
 };
 ^
..\src\N_tree.cpp: At global scope:
..\src\N_tree.cpp:27:1: error: expected ';' at end of input
 }
 ^
10:31:10 **** Incremental Build of configuration Debug for project tmp ****
Info: Internal Builder is used for build
g++ -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\N_tree.o" "..\\src\\N_tree.cpp" 
g++ -o tmp.exe "src\\N_tree.o" 
Info: Nothing to build for tmp
Info: Nothing to build for tmp
